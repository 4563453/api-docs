'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/api-docs/docs/contributing/',title:"Contributing",section:"Docs",content:"Contributing #  Thanks for wanting to contribute to the api-docs! We are grateful for your help.\nContributing to the API Docs. #  Anyone can contribute to the docs. We only ask that you follow a few guidelines when contributing.\n  Follow the file structure. Each topic (or sub-topic) has language specific folders and a basic guide. Inside each language folder there should be a tutorial and a code file if applicable. You do not need to tackle an entire topic by yourself. Completing even one tutorial is helpful!\n  Follow the tutorial structure. Try to keep each tutorial as objective as possible. You can have some personal expression but try to keep it limited. We want these guides to be as short and as simple as they can get. The tutorial should be written in Markdown. Explain every step and clearly document any code used. Don\u0026rsquo;t do this.\n  Run any code through a prettier software. Try to keep the code looking nice! It doesn\u0026rsquo;t matter which formatter you use but we want the code to be readable.\n  Follow the Glimesh and Github TOS (Terms of Service). Any tutorial that violates either of the TOS will be removed. Any malicious code will be removed.\n  Process #  Start by forking the repository. Access the fork on your PC or on https://github.com/YOURNAME/api-docs . You will want an environment capable of editing markdown (.md) files. Any IDE will do.\n Stack Edit is a free markdown editor running in the browser. It is easy to use and has many tools for markdown formatting. You can copy the contents of the files there to edit them.\n You will need to create your tutorial as described above. You will also need Hugo installed. Get the extended features edition.\n This installation can be a bit complex for Windows users so you may want to follow a tutorial.\n In the command line navigate to the folder containing your fork. Run hugo server --minify --theme book in your terminal. If you get a theme error you can run git clone https://github.com/alex-shpak/hugo-book themes/book or install the git submodules. It will install the necessary theme files. When it finishes installing run the server command again. This will open a server on http://localhost:1313/api-docs.\n The server will restart when any changes are saved. Editing config or other important files will require a manual restart though.\n You can add special markdown formatting if you want to. If you are making a new file Hugo will detect the it and update the menu on the left side of the page with your new file. The menu will alter itself to match the file directory. This may require a restart of the server for the menu to update.\n Notice that every folder with content has a _index.md file. Create a new _index.md file and fill it with the info below if you created a new folder. This allows the tutorial to be collapsible in the menu. If the weight is the same they will be alphabetically sorted.\n --- bookCollapseSection: true weight: 20 --- When you are satisfied with the look of your tutorial you can submit a PR. Close the server. Commit and push your changes. Create a pull request with a brief overview of your tutorial/topic. We may ask you to make changes. Once accepted we will add your tutorial to the repo and add it to the website.\nThank you for contributing!\n"}),a.add({id:1,href:'/api-docs/docs/dev-app/',title:"Dev App",section:"Docs",content:"Developer Application #  Although making an application is easy, developers new to OAuth may find some of it confusing. This tutorial will explain the basics of what information is asked for and what is it used for.\n Ready to make your application? Start here\n Name #  The name of your project is a user friendly name for your application. Both Glimesh and your users will see this when they authenticate with your app.\nHomepage #  The homepage of your app is where your product (if applicable) is located. This could be a website for a chatbot, an online tool, or anything that uses the Glimesh API. You do not need to have a public domain to show your product if you don\u0026rsquo;t want to. Using a localhost URL is fine.\nDescription #  The description is a basic explanation of your app. This should be a brief overview of what your app will be used for. Details, details, details!\nImage #  The image you choose here is shown to all users who authenticate with your app. It should be representative of your app and must not violate the Glimesh Terms of Service.\nAllowed Redirect URIs #  The redirect URIs are where Glimesh will redirect users of your app after they authenticate with your app. You specify which one to redirect to in the client request. You should have one URL per line. We prefer HTTPS over HTTP but using a locally hosted HTTP server will be fine.\nA complete dev app will look like this when authenticating.\n"}),a.add({id:2,href:'/api-docs/docs/authentication/accesstoken/clientcredentials/',title:"Client Credentials",section:"Access Token",content:"Client Credentials (Access Token) #  An access token can be used to query the Glimesh API on behalf of a user. Normally you have to get a token from a user. Client credentials allows us to generate an access token for our own account to act as an authenticated user. This is frequently used for testing purposes.\nRequesting A Token #  Before requesting a token you must have a developer application. You will need your client ID and secret key. Simply make a POST request to the following URL replacing CLIENT_ID and SECRET_KEY with the info from your dev app.\nhttps://glimesh.tv/api/oauth/token?grant_type=client_credentials\u0026amp;client_id=CLIENT_ID\u0026amp;client_secret=SECRET_KEY Glimesh will respond with:\n{ \u0026#34;access_token\u0026#34;: \u0026#34;qwertyuiop1234567890\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2021-03-21T19:32:21\u0026#34;, \u0026#34;expires_in\u0026#34;: 21600, \u0026#34;refresh_token\u0026#34;: null, \u0026#34;scope\u0026#34;: \u0026#34;public\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34; } The access token received will allow us to make requests as if we were using a normal access token. We have permissions for all the scopes and have access to any user specific properties. The token generated will expire in 6 hours just like a normal token. Unlike normal tokens, this cannot be refreshed. As with all auth information you must keep this private.\nIf you have any questions talk to us in the #dev-questions channel in our Discord.\n"}),a.add({id:3,href:'/api-docs/docs/api/api-explorer/',title:"API Explorer",section:"API",content:"API Explorer #  Insomnia is a GraphQL explorer. It allows you to make queries without needing a dev environment. It is the recommended way to learn the API and is helpful if you are new to programming.\n We have a JSON file with a collection to handle auth and make common requests in Insomnia. You can download it here\n Getting Started #  First we need to download Insomnia. They have a free tier which is more than enough for our purposes. Insomnia can be downloaded here. You don\u0026rsquo;t need to make an account to use the app. When the download is complete, you can skip your way through setup and get to the collection viewer.\nGlimesh Collection #  If you downloaded the Glimesh Collection this will be a very fast setup. Drag the file directly into the editor. This will import all our requests and our environment variables.\nFirst we need to set up our variables to authenticate our requests. On the top left select the \u0026ldquo;no environment\u0026rdquo; button. Then \u0026ldquo;manage environments\u0026rdquo; . Add your client ID / secret to their matching values. If you do not yet have an ID you can get one by creating a dev app.\nInsomnia will automatically run the auth request now that the variables are filled in.\nThe file contains a few common requests. To test one, click on the request. Then select the send button. Your response will appear on the right.\nAll the requests in this file have the auth header. If you make a new request you will have to add it yourself. Simply have the header name as \u0026ldquo;Authorization\u0026rdquo; and the value your access_token environment variable (ctrl+space to view env variables). You can use the default_url variable for the URL.\nManual Setup #  Create a new collection. For this tutorial we will call this collection \u0026ldquo;Glimesh\u0026rdquo;.\nFirst we will handle authentication. Generally it\u0026rsquo;s easiest to make 1 auth request and have your credentials be environment variables. We will start with the variables first. On the top left press environment. Then manage environments. Copy the below JSON into the box.\n{ \u0026#34;base_url\u0026#34;: \u0026#34;https://glimesh.tv/api/graph\u0026#34;, \u0026#34;client_id\u0026#34;: \u0026#34;YOUR_ID_HERE\u0026#34;, \u0026#34;client_secret\u0026#34;: \u0026#34;YOUR_SECRET_HERE\u0026#34;, \u0026#34;access_token\u0026#34;: \u0026#34;Bearer \u0026#34; } Copy your ID/secret into their places. For the access token we need to make a request that will authenticate you. Close the environments box.\nCreate a new request on the left. Use https://glimesh.tv/api/oauth/token for the URL. It needs to be a POST request with a multipart-form body. Title the request Auth.\nUse the following values for the form entries.\nThe purple boxes are the variables from earlier. Press ctrl+space to view all variables and select the proper variables. To verify that the request is valid send the request. You should receive an access token from the response. If you don\u0026rsquo;t receive one make sure all the values are correct.\n Note that I have 5 headers, you will not have that many for this request. The default Insomnia headers will suffice.\n Next we need to set our access token to the access_token variable in Insomnia. Open the environment tab from earlier. In the access token value after Bearer press ctrl+space. Select response =\u0026gt; body-attribute. Click on the box that appeared in the value.\nRequest must be set to out Auth Request from eariler. Filter must be $.access_token . This pulls the token from the auth response. The trigger behavior must be set to \u0026ldquo;when expired\u0026rdquo;. Max age is 21600 (the life of the token). Select done. Close the variable window.\nNow we can make a request to get data from the API. Create a new request. You can use the base_url variable or enter the URL manually.\nhttps://glimesh.tv/api/graph\nIt needs to be a POST request and have a body type of graphql. We need to add our auth info from the previous request. Head to the header section. The name needs to be \u0026ldquo;Authorization\u0026rdquo; and the value needs to be your access_token variable.\nNow we can head back to the GraphQL section. You can make any query but we will request the user ID from a user. Copy the below query into the section.\nquery { user(username: \u0026#34;Mytho\u0026#34;) { id } } All that\u0026rsquo;s left is to make the request! Select send on the top and the result will be on the right. You can make any number of requests in this format. The Glimesh collection includes basic requests and can be downloaded here\nGenerating Code #  Insomnia can generate code based on your request to the API. Although the code will work, it could likely use some optimizing based on your needs. Insomnia supports most programming languages, so choose the one that matches your project. Right click on a request and select generate code.\nThis will open a box and you can choose the format and language. If you have any questions about using the Glimesh collection or using the Glimesh API let us know in #dev-questions in our discord.\n"}),a.add({id:4,href:'/api-docs/docs/api/live-updates/channels/',title:"Channels",section:"Live Updates",content:"Channel Changes #  Using graphQL subscriptions we can listen for changes to a channel without making repeated queries! Before starting this tutorial you should understand basic graphQL and have a method of authentication. Completing our websocket tutorial will also be helpful.\n Need authentication? Start with access tokens\n  Websocket tutorial can be found here\n Selecting a Channel #  Before we can subscribe to a user we need a channel ID. This will specify which channel we are wanting to connect to. The easiest way to get a channel ID is to and make the following query. Simply replace YOURNAME with the channel you want to listen to.\nquery { channel(streamerUsername: \u0026#34;YOURNAME\u0026#34;) { id } } Glimesh will return a response that should look something like this.\n{ \u0026#34;data\u0026#34;: { \u0026#34;channel\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34; } } } Building Our Subscription #  Now that we have a channel ID we can build our subscription query. Glimesh will send us data through this subscription whenever a change is made to the selected channel. Our query needs to specify the information we want returned when this happens.\n Note that any change to the channel will result in data being sent even if you did not listen for that specific change. The data received will contain the query and nothing more.\n To keep things simple we will listen for a change in the channel title.\nsubscription { channel(id:6) { title } }  Don\u0026rsquo;t forget to replace 6 with your channel ID!\n If Glimesh detects a change in the channel it will send us the data that we asked for. As noted above any change will cause this data to be sent, not just a title change. Next we will create a connection to Glimesh and send them our subscription!\nWebsocket Connection #  Since this is a subscription a websocket connection is needed. If you have followed the chat websocket tutorial you can modify that code to fit this tutorial. If you have not done so you must do the following -\n  Create a connection URL:\n  For Access Tokens: wss://glimesh.tv/api/socket/websocket?vsn=2.0.0\u0026amp;token=TOKEN_HERE\n  For Client IDs: wss://glimesh.tv/api/socket/websocket?vsn=2.0.0\u0026amp;client_id=CLIENT_ID\n   Make sure to replace TOKEN_HERE or CLIENT_ID with their proper values!\n   Open a connection and send this through:\n  [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;__absinthe__:control\u0026quot;,\u0026quot;phx_join\u0026quot;,{}] Send this through replacing 6 with your channel ID.  [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;__absinthe__:control\u0026quot;,\u0026quot;doc\u0026quot;,{\u0026quot;query\u0026quot;:\u0026quot;subscription{ channel(ID: 6) { title, id } }\u0026quot;,\u0026quot;variables\u0026quot;:{} }] Send this through every 30 seconds.  [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;phoenix\u0026quot;,\u0026quot;heartbeat\u0026quot;,{}]  Having issues? The websocket tutorial goes into more detail about the connection. You may find it helpful to complete that tutorial first. If you are still having problems talk to us in discord.\n The above code will connect to Glimesh, subscribe to any changes, and keep us from getting disconnected. To test our code we need to make a change on the channel that we specified. We requested to be sent the current title. Lets change it and see our code in action!\nBefore (Basic Query)\n{ \u0026#34;data\u0026#34;: { \u0026#34;channel\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Hello Glimesh API \u0026#34; } } } After (Websocket)\n[ null, null, \u0026#39;__absinthe__:doc:-576460752299317854:BEF9A4EF11FCFAD0A1B750BCEE8C2CBEAB66ADDAFE214A6CF692FBA68473F68A\u0026#39;, \u0026#39;subscription:data\u0026#39;, { result: { channel: { id: \u0026#39;6\u0026#39;, title: \u0026#39;Hello Glimesh API \u0026#39; } }, subscriptionId: \u0026#39;__absinthe__:doc:-576460752299317854:BEF9A4EF11FCFAD0A1B750BCEE8C2CBEAB66ADDAFE214A6CF692FBA68473F68A\u0026#39; } ] After the title was changed Glimesh sent us the new title. All properties will function the same way. Using this format you can listen to any property of any channel on Glimesh!\n Looking for a reference? Click here to view all the channel properties.\n If you have any questions talk to us in the #dev-questions channel in our Discord.\n"}),a.add({id:5,href:'/api-docs/docs/api/live-updates/followers/',title:"Followers",section:"Live Updates",content:"Follower Alerts #  This is a tutorial for follow alerts. This guide assumes you have a client ID or an access token from a user. You should also have a websocket connection open from this tutorial. Having basic GraphQL knowledge would also be helpful.\n New to GraphQL? This tutorial explains the basics. https://graphql.org/learn/schema/\n Building the Subscription #  Follow alerts are made of a standard subscription. The streamer ID of the channel that you want to have alerts for is required. A streamer ID is equal to the user ID. You can acquire the ID with the below query.\nquery { user(username:\u0026#34;Mytho\u0026#34;) { id } }  Make sure to replace Mytho with the channel name.\n We will insert this ID into the below subscription. You must subscribe to this event through a websocket connection. Glimesh will notify us whenever a user follows the channel.\nsubscription { followers(streamerId:6) { hasLiveNotifications, id, insertedAt, streamer { username }, updatedAt, user { username } } } The above subscription shows all of the properties we can receive. This excludes nested properties. This information will be sent to us whenever the specified channel gets a new follower.\n Need a tutorial for connecting to the API with websockets? Click here\n Follower Query #  A subscription is the standard way to get follower alerts. However, this is not the only method to get the followers of a channel. We can make a query to get the followers of a channel as well as the followers of a user. You will need the ID of the streamer or of the user. The following query will return the followers of a streamer.\n streamerId is the user ID, not the channel ID.\n  Followers are paginated, see our guide on that here\n query { followers(streamerId: 6) { edges { node { hasLiveNotifications id insertedAt streamer { username } updatedAt user { username } } } } } We requested the same properties as before. Glimesh will send us a JSON format response.\n{ \u0026#34;data\u0026#34;: { \u0026#34;followers\u0026#34;: { \u0026#34;edges\u0026#34;: [ { \u0026#34;node\u0026#34;: { \u0026#34;hasLiveNotifications\u0026#34;: false, \u0026#34;id\u0026#34;: \u0026#34;613\u0026#34;, \u0026#34;insertedAt\u0026#34;: \u0026#34;2020-08-09T15:14:21\u0026#34;, \u0026#34;streamer\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; }, \u0026#34;updatedAt\u0026#34;: \u0026#34;2020-08-09T15:14:21\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } } }, { \u0026#34;node\u0026#34;: { \u0026#34;hasLiveNotifications\u0026#34;: false, \u0026#34;id\u0026#34;: \u0026#34;629\u0026#34;, \u0026#34;insertedAt\u0026#34;: \u0026#34;2020-08-09T16:35:55\u0026#34;, \u0026#34;streamer\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; }, \u0026#34;updatedAt\u0026#34;: \u0026#34;2020-08-09T16:35:55\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;TheCat\u0026#34; } } }, and so on... We can also request who a user is following. The query is nearly identical. The only thing we change is the parameter. Replace streamerId with userId.\nquery { followers(userId: 6) { edges { node { hasLiveNotifications id insertedAt streamer { username } updatedAt user { username } } } } } Stuck with something? Talk to us in Discord. We would be happy to help you!\n"}),a.add({id:6,href:'/api-docs/docs/api/migration/',title:"Migration",section:"API",content:"API Migration #  Glimesh has started migrated to a new API because of major changes in the way result data is returned from the API. We\u0026rsquo;ve added pagination to all queries that return lists to improve performance on the app, and renamed several fields for consistency.\nIn addition, we are in the process of migrating to a new OAuth 2.0 provider which adds additional features, but may require some changes for your application. The migration to the new OAuth 2.0 provider will complete on August 20th 2021 at 8AM EDT.\n If you are new to the API you can safely skip this doc.\n Timeline #  The new API endpoint has already been introduced, however there are currently no plans to remove the old API endpoint. However we will be soon pointing all new developers to our new API only, and removing documentation relating to the older API as we continue to prove the new one out.\nUsing the New API #  Using the new API is very easy. Simply point all requests to the new URL.\nHTTP Endpoint: https://glimesh.tv/api/graph WebSocket Endpoint: https://glimesh.tv/api/graph/websocket This will give you full access to the new endpoints and features of the API.\nWhat Changed? #  Some changes are internal and do not affect the developer. However, the following changes will affect you:\n The new API endpoint does not support a built-in graphical editor. This change was required to properly support CORS across the new API endpoint. We have a new tutorial about using your own editor here. Query Complexity analysis has been added which will help us maintain API performance. You should not run into any limits with any possible queries (due to pagination), but if you do receive errors about query complexity, let us know so we can check it out!    The following fields have been added to the API.  Category  insertedAt: Creation time of the category. updatedAt: When the category was last updated.   Channel  chatBgUrl : The URL of the channels chat background. posterUrl: Image that is shown in place of the stream when the user is offline. Streams: List of the streams the channel currently has (1). See pagination.   Channel Ban  id: The ID of the channel ban.   Channel Moderator  id: The ID of the channel moderator.   Stream  thumbnailUrl: The URL of the current thumbnail (stream snapshot)   User  allowGlimeshNewsletter: Does the user allow newsletters? allowLiveSubscriptionEmails: Does the user allow \u0026ldquo;going live\u0026rdquo; emails? channel: The user\u0026rsquo;s channel. email: The user\u0026rsquo;s email address (scope protected). followingLiveChannels: The channels that the user is following that are currently streaming. insertedAt: When the user was inserted into the database. showOnHomePage: Has the user enabled the selection to be on the homepage? teamRole: The role the user has on the Glimesh Team (dev, design, GCT, etc) updatedAt: The last time the user was modified.        The following are now paginated and no longer return every item in the collection at once. See pagination  Subcategories Tags Channels Channel Bans Channel Chat Messages Channel Moderation Logs Channel Streams Channel Moderator List Followers Users User Followers User Following User Following Live Channels      The following fields have been removed from the API. Some have been moved or had their names changed to a new field.  Channel  thumbnail: Moved to Stream as thumbnailUrl Replaced hmackey and username as arguments. Added streamerId and streamerUsername   deleteMessage  Changed to deleteChatMessage   Emote Token  url: Use src instead.   Followers  Replaced streamerUsername and userUsername as arguments. Added streamerId and userId   Stream  avgChatters avgViewers countChatters newSubscribers resubSubscribers subcategory: Moved to Channel. thumbnail: Changed to thumbnailUrl.   User  avatar: Use avatarUrl instead.      Using the New Authentication #  The new authentication method will not require any changes for the user. However, it does add support for PKCE auth.\nWhat Changed? #  Credentials now use new formats. Client IDs and Secret Keys will be converted for each request you make. This means you do not need to change your keys. However, we recommend that you migrate to the new format whenever possible. Simply rotate the existing keys from the dev app and replace them in your projects.\n Access/Refresh Tokens  Can now contain upper case values. Max length increased to 255 characters.   Client ID  Are now UUID’s instead of alpha-numeric values.   Client Secret  Can now contain upper case values. Max length increased to 255 characters.    Our OAuth system now supports PKCE auth. This is a new standard and it is not required to use the API. We have a guide on getting it setup shortly.\n"}),a.add({id:7,href:'/api-docs/docs/api/pagination/',title:"Pagination",section:"API",content:"API Pagination #  Some fields in the API are paginated. We have to sort through the pages to get the data we requested. Glimesh follows the GraphQL pagination spec.\n GraphQL pagination can be found here\n Connection, Edges, and Nodes #  Pagination is used when the data requested is too large to send to the user. Take the below query as an example. This query would return the ID of all the users on the site. This would take a long time for Glimesh to get the data and would be a large payload to send.\nquery { users { id } } # Above query will not work :( Instead of sending all the users, Glimesh sends us a UserConnection. This contains data on how to get the data we requested.\n Note that each paginated field has its own Connection type. They always correspond to the field requested. Since we queried users we received a UserConnection\n Connections #  Connections contain a count of all the edges, the edges themselves, and a pageInfo. They help us get the data we requested, and show us how much data we can paginate through.\nusers { count, # How many edges exist on this query edges {}, # Some edges that match the query pageInfo {} # pageInfo containing info on the page returned } The count returns how many edges exist based on your query. This does not return the total amount of edges. For example, if you ask for the first 5 results you will have a count of 5, even though the total amount of edges is far more.\nEdges #  Each edge contains a cursor and a node. The cursor is a string of text that identifies the edge. The node is the data on that edge. Each node has 1 item we queried (in this case a user).\nedges { cursor,# Unique ID that identifies the node node {id, username} # The node contains data that we requested } PageInfo #  A PageInfo object exists on every connection. They contain an end and start cursor, as well as a hasNextPage and hasPreviousPage. Pageinfo can be used to determine if there is any more data to paginate through.\n Note that the next and previous are determined by the first item returned, not the last.\n pageInfo { endCursor, # ID of the last cursor for the connection hasNextPage, # bool hasPreviousPage, # bool, startCursor # ID of the first cursor for the collection } Paginating Through Data #  Now that we know how pagination works, let\u0026rsquo;s get the 5 most recent users and the first 5 users on Glimesh. All the necessary queries are posted below, but you will need to run them in your own project or use a graphql explorer.\nFirst we start by making a query to get the first 5 users. We can query more at a time, but for this tutorial 5 will suffice. We also ask for the cursor of each edge.\nRequest query { users(first: 5) { edges { cursor node { id username } } } } Result { \u0026#34;data\u0026#34;: { \u0026#34;users\u0026#34;: { \u0026#34;edges\u0026#34;: [ { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjA=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;clone1018\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjE=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;IKAROS\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjI=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Kristoff\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjM=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Ember\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQ=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Heiwa\u0026#34; } } ] } } }  Now we have the first 5 users. Since we also have the cursors of each edge we could query the next 5. Take the below query as an example. We still ask for the first 5 but we request it after the 5th edge from the last query.\nRequest query { users(first: 5, after: \u0026#34;YXJyYXljb25uZWN0aW9uOjQ=\u0026#34; ) { edges { cursor node { id username } } } } Result { \u0026#34;data\u0026#34;: { \u0026#34;users\u0026#34;: { \u0026#34;edges\u0026#34;: [ { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjU=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Bubdrum\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjY=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;7\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Deicefenrir\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjc=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;8\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Umbreo\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjg=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;9\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;UnTubular\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjk=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Asterisk\u0026#34; } } ] } } }  Now we have the next 5 users. You can use this to move through the entire database. However, we wanted the last 5 users. We could continue in this way (although we would query more than 5 at a time!) but there is an easier way. We can use the last parameter. Simply replace first with last from the first query.\nRequest query { users(last: 5) { edges { cursor node { id username } } } } Result { \u0026#34;data\u0026#34;: { \u0026#34;users\u0026#34;: { \u0026#34;edges\u0026#34;: [ { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDc1\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42336\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Emad\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDc2\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42337\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Mr_Emotional\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDc3\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42338\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;BruteMouse\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDc4\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42339\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Bruhh\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDc5\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42340\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;VeganGaymer\u0026#34; } } ] } } }  This will return the 5 most recent users. Glimesh adds users in the order that they were created, so these users have the highest user IDs.\n Note that you will get a different result. Users have been added since this doc was written, so you will get different users.\n We can also request pageInfo with each paginated query. This will tell us if there is another page after or before our result, and show us the first and last cursor of our result. For our queries this wasn\u0026rsquo;t neccassary, but if you plan to paginate through a large amount of users it is very helpful. The below query gets 5 users before the last 5 users with the before parameter.\nRequest query { users(last: 5, before: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDc1\u0026#34;) { edges { cursor node { id username } }, pageInfo { endCursor, # ID of the last cursor for the result hasNextPage, # bool hasPreviousPage, # bool, startCursor # ID of the first cursor for the result } } } Result { \u0026#34;data\u0026#34;: { \u0026#34;users\u0026#34;: { \u0026#34;edges\u0026#34;: [ { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDcw\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42331\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;FsnGaming\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDcx\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42332\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;ajsdlasdasd\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDcy\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42333\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;dfhdhsad\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDcz\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42334\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;dqbyudvbqhdbvzh\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDc0\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42335\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Elitex\u0026#34; } } ], \u0026#34;pageInfo\u0026#34;: { \u0026#34;endCursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDc0\u0026#34;, \u0026#34;hasNextPage\u0026#34;: true, \u0026#34;hasPreviousPage\u0026#34;: true, \u0026#34;startCursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDcw\u0026#34; } } } }  The same process applies for all paginated fields. If you have any questions be sure to let us know in discord!\n"}),a.add({id:8,href:'/api-docs/docs/api/query-api/basic-query/',title:"Basic Query",section:"Query API",content:"Glimesh API Requests #  This is a basic tutorial for communicating with the Glimesh API. This guide assumes you have a client ID or an access token from a user. Having basic GraphQL knowledge would also be helpful.\n New to GraphQL? This tutorial explains the basics. https://graphql.org/learn/schema/\n Authentication #  All requests made to Glimesh must contain the proper authentication. The authentication value should be included as a header of the request. This value will change depending on the authentication type. For access tokens use:\nAuthorization: Bearer YOUR_TOKEN\nReplace YOUR_TOKEN with your access token. If you are using a client ID to authenticate you must use this instead:\nAuthorization: Client-ID YOUR_CLIENT_ID\nReplace YOUR_CLIENT_ID with your ID. This will allow you access to the API.\n A client ID can use the API in read only mode. An access token is limited by its scopes.\n Building Our Request #  The Glimesh API uses GraphQL. You must structure your query accordingly. Some data requires an access token with a special scope. For this example we will structure a basic request that requires no special scope. The query must be included in the body of the request.\nquery { user(username: \u0026#34;USERNAME\u0026#34;) { username id } } Make sure to change \u0026ldquo;USERNAME\u0026rdquo; to a user on Glimesh. We are requesting the username and ID of the user. Now that we have our authentication and our query we can request the data. Send a POST request with our query and header from above to:\nhttps://glimesh.tv/api/graph Glimesh will send a JSON formatted response when it receives our request.\n{ \u0026#34;data\u0026#34;: { \u0026#34;user\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;154\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } } } You can parse the response to get the data you want. You could test every query like this but there is an easier way.\nAPI Explorer #  You can use an API explorer to make queries without the need of a dev environment. API explorers let you run queries with intellisense and some even handle authentication for you.\nWe have a dedicated tutorial on using the Insomnia GraphQL editor here. We also provide a collection of common requests which can be found in that tutorial.\nIf you have any questions feel free to talk to us in Discord.\nCommon Errors #  There are a few errors you may encounter while querying the API.\nError: 401 Unauthorized. You must be logged in to access the API.\nThis is an authentication issue. Check your authentication header. You need to use the right type of authentication and make sure that the information is valid.\n  Internal Server Error  This is usually user error rather than a server error. Ensure the auth info is correct and check your query for errors. If you think your query is correct try it here.\n  syntax error before: \\\u0026quot;\\\\\\\u0026quot;QUERY\\\\\\\u0026quot;\\\u0026quot;\u0026quot;  Your query is in the incorrect format. It must match the GraphQL specifications. You can only request properties that exist and you must have the proper permissions to access them. Check the API docs for more information.\n Stuck with something? Talk to us in Discord. We would be happy to help you!\n "}),a.add({id:9,href:'/api-docs/docs/api/query-api/nodejs/node-query/',title:"Node Query",section:"Query API",content:"Glimesh API Requests With NodeJS #  This is a basic tutorial for communicating with the Glimesh API using NodeJS. This guide assumes you know basic JS and have an access token from a user. You can use a client ID if you do not yet have a token. Having basic GraphQL knowledge would also be helpful.\n Need a refresh? This tutorial explains the basics of graphql. https://graphql.org/learn/schema/\n Creating the Project #  We need to create a basic project. In your terminal type\nnpm init -y .\nThis will create a project.JSON file. This project uses the Request npm package. It helps with sending requests to the server and handling the response. In your terminal type\nnpm install request.\nThat is the only package that you will need!\nStarting Up #  In your project create a blank JS file. I will title mine \u0026ldquo;glimesh.js\u0026rdquo;. Start by importing the Request library. Paste this at the top of your file.\nvar request = require('request'); Now we need to build our query. In this example we will ask Glimesh for the name and ID of our user. If you are using an access token you can get this data in the myself object. query{ myself { username, id } } However, we need to convert this so JS can understand it. To do this we create a data variable. Paste this under the import statement above.\nvar data = ` query { myself { username, id} } ` If you are going to use a client ID you have to specify which user to get data for. This is because a client ID does not have a user identity. This query will return the same data as the myself object.\nvar data = ` query { user (username: \u0026#34;USERNAME\u0026#34;){ username, id} } ` Feel free to replace USERNAME with your own username! Since we are not accessing any private information we do not need any special permissions/scopes.\n Leave the quotations around \u0026quot;USERNAME\u0026quot;. Glimesh processes our query as graphQL. Even though data is a string Glimesh will convert it to graphQL when it receives our request. GraphQL requires that the user we search for be a string. Since we used `` to encase the contents of data, quotations must be used to keep your username a string.\n Define Options #  Next we set up the call to the API. We need to add our data variable from above and our authentication as a header. We do this with the options variable. If you do not already have an authentication method (Client ID or Access Token) you need to get one now. Paste this below your query.\nvar options = { method: \u0026#39;POST\u0026#39;, body: data, url: \u0026#39;https://glimesh.tv/api/graph\u0026#39;, headers: { \u0026#39;Authorization\u0026#39;: \u0026#39;Bearer Your_Token\u0026#39; } }; Notice we are sending the data variable from before. If you are using an access token replace \u0026ldquo;Your_Token\u0026rdquo; with your access token in the Authorization string. It should look like this. 'Authorization': 'Bearer qertyuiop123456789'\nIf you are using a client ID replace \u0026ldquo;Bearer\u0026rdquo; with \u0026ldquo;Client-ID\u0026rdquo; and \u0026ldquo;Your_Token\u0026rdquo; with your client ID. It should look like this.\n'Authorization': 'Client-ID qwertyuiop123456789'\nSend Request #  Now we set up the request. We ask Glimesh for data and we setup a callback function to handle it when it arrives. The server will normally respond in less than one second. Paste this below the options variable.\nfunction callback(error, response, body) { if (!error \u0026amp;\u0026amp; response.statusCode == 200) { //if all works as it should...  console.log(body); //The unfiltered response  var convertedResponse = JSON.parse(body); //Convert the response so we can use it  console.log(`The user is ${convertedResponse.data.myself.username}and the ID is ${convertedResponse.data.myself.id}`); } else { console.log(error) //log any errors.  console.log(body) //sometimes the body contains the error.  } } If you searched for a user instead of myself you need to change the convertedResponse output to:\nconsole.log(`The user ${convertedResponse.data.user.username}has an ID of ${convertedResponse.data.user.id}`); Finally we send the request. At the bottom of the file add this line.\nrequest(options, callback); When you are ready, save the file and type the line below in your terminal to query the API!\nnode filename.js\nMake sure to replace \u0026ldquo;filename\u0026rdquo; with the name of your file! For example -\nnode glimesh.js\nCommon Errors #   You must be logged in to access the API.   Cause: The auth string is incorrect. Make sure the token is valid. They expire after a short period and a new token is needed. You should also check the auth string. It should look like this 'Authorization': 'Bearer qertyuiop123456789' or 'Authorization': 'Client-ID qertyuiop123456789' depending on the auth method you used.\n  Internal Server Error   Cause: This is usually user error rather than a server error. Ensure the auth info is correct and check your query. The query is a string but the contents of that variable are graphQL. If you think your query is correct try it in a graphql explorer. Don\u0026rsquo;t forget to remove the `` when testing in an editor! Note that you must be signed in to use the API website!\n  syntax error before: \\\u0026quot;\\\\\\\u0026quot;query\\\\\\\u0026quot;\\\u0026quot;\u0026quot;   Cause: Your query is in the incorrect format. Ensure it matches the example in the code above. You can only request properties that exist and you must have the proper permissions to access them.\n Conclusion #  This is the basis for most API requests. If you have any questions let us know in the #dev-questions channel in our Discord.\nThe full file can be found here.\nvar request = require(\u0026#39;request\u0026#39;); //Import the library //Define the data we want from Glimesh. var data = ` query { myself { username, id} } ` // If you used a client ID the myself object will not exist. Try this: /* var data = ` query { user (username: \u0026#34;USERNAME\u0026#34;){ username, id} }` */ //Make sure to replace USERNAME with a user!  //Tell the request library where to send the request and how to add auth var options = { method: \u0026#39;POST\u0026#39;, body: data, url: \u0026#39;https://glimesh.tv/api/graph\u0026#39;, headers: { \u0026#39;Authorization\u0026#39;: \u0026#39;Bearer Token_Here\u0026#39; //If you are using a client ID use \u0026#39;Authorization\u0026#39;: \u0026#39;Client-ID qwertyuiop123456789\u0026#39;  } }; //Callback function runs when the data is recieved. We convert it to an object on arrival. function callback(error, response, body) { if (!error \u0026amp;\u0026amp; response.statusCode == 200) { console.log(body); //The unfiltered response  var convertedResponse = JSON.parse(body); //Convert the response  console.log(`You are ${convertedResponse.data.myself.username}and your ID is ${convertedResponse.data.myself.id}`); // If you are using a client ID you will have requested the user object. Use the line below instead!  // console.log(`The user ${convertedResponse.data.user.username} has an ID of ${convertedResponse.data.user.id}`);  } else { console.log(error); //log any errors  console.log(body); } } //send the request request(options, callback); "}),a.add({id:10,href:'/api-docs/docs/api/voyager/',title:"Voyager",section:"API",content:'Voyager is an interactive GraphQL API explorer. It allows you to view all the data in our API. Click and drag to move around the explorer. Click on a field to view its properties. Scoll to adjust zoom.\nLoading...  // Render GraphQLVoyager.init(document.getElementById(\'voyager\'), { hideDocs: true, hideSettings: false, displayOptions: { sortByAlphabet: true, }, introspection: { "data": { "__schema": { "directives": [ { "args": [ { "defaultValue": null, "description": "Included when true.", "name": "if", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } } ], "description": "Directs the executor to include this field or fragment only when the `if` argument is true.", "locations": [ "FIELD", "FRAGMENT_SPREAD", "INLINE_FRAGMENT" ], "name": "include" }, { "args": [ { "defaultValue": null, "description": "Skipped when true.", "name": "if", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } } ], "description": "Directs the executor to skip this field or fragment when the `if` argument is true.", "locations": [ "FIELD", "FRAGMENT_SPREAD", "INLINE_FRAGMENT" ], "name": "skip" } ], "mutationType": { "name": "RootMutationType" }, "queryType": { "name": "RootQueryType" }, "subscriptionType": { "name": "RootSubscriptionType" }, "types": [ { "description": "Represents a directive", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "args", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "LIST", "name": null, "ofType": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "__InputValue", "ofType": null } } } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "description", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "isRepeatable", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "locations", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "LIST", "name": null, "ofType": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "ENUM", "name": "__DirectiveLocation", "ofType": null } } } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "name", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "String", "ofType": null } } }, { "args": [], "deprecationReason": "Check `locations` field for enum value FIELD", "description": null, "isDeprecated": true, "name": "onField", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": "Check `locations` field for enum value FRAGMENT_SPREAD", "description": null, "isDeprecated": true, "name": "onFragment", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": "Check `locations` field for enum value OPERATION", "description": null, "isDeprecated": true, "name": "onOperation", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "__Directive", "possibleTypes": null }, { "description": null, "enumValues": [ { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "ARGUMENT_DEFINITION" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "ENUM" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "ENUM_VALUE" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "FIELD" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "FIELD_DEFINITION" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "FRAGMENT_DEFINITION" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "FRAGMENT_SPREAD" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "INLINE_FRAGMENT" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "INPUT_FIELD_DEFINITION" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "INPUT_OBJECT" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "INTERFACE" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "MUTATION" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "OBJECT" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "QUERY" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "SCALAR" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "SCHEMA" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "SUBSCRIPTION" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "UNION" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "VARIABLE_DEFINITION" } ], "fields": null, "inputFields": null, "interfaces": null, "kind": "ENUM", "name": "__DirectiveLocation", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "deprecationReason", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "description", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "isDeprecated", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "name", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "String", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "__EnumValue", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "args", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "LIST", "name": null, "ofType": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "__InputValue", "ofType": null } } } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "deprecationReason", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "description", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "isDeprecated", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "name", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "String", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "type", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "__Type", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "__Field", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "defaultValue", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "description", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "name", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "String", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "type", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "__Type", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "__InputValue", "possibleTypes": null }, { "description": "Represents a schema", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "description", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "directives", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "LIST", "name": null, "ofType": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "__Directive", "ofType": null } } } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "mutationType", "type": { "kind": "OBJECT", "name": "__Type", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "queryType", "type": { "kind": "OBJECT", "name": "__Type", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "subscriptionType", "type": { "kind": "OBJECT", "name": "__Type", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "types", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "LIST", "name": null, "ofType": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "__Type", "ofType": null } } } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "__Schema", "possibleTypes": null }, { "description": "Represents scalars, interfaces, object types, unions, enums in the system", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "description", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [ { "defaultValue": "false", "description": null, "name": "includeDeprecated", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "enumValues", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "__EnumValue", "ofType": null } } } }, { "args": [ { "defaultValue": "false", "description": null, "name": "includeDeprecated", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "fields", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "__Field", "ofType": null } } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "inputFields", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "__InputValue", "ofType": null } } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "interfaces", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "__Type", "ofType": null } } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "kind", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "ENUM", "name": "__TypeKind", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "name", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "ofType", "type": { "kind": "OBJECT", "name": "__Type", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "possibleTypes", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "__Type", "ofType": null } } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "__Type", "possibleTypes": null }, { "description": null, "enumValues": [ { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "ENUM" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "INPUT_OBJECT" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "INTERFACE" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "LIST" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "NON_NULL" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "OBJECT" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "SCALAR" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "UNION" } ], "fields": null, "inputFields": null, "interfaces": null, "kind": "ENUM", "name": "__TypeKind", "possibleTypes": null }, { "description": "The `Boolean` scalar type represents `true` or `false`.", "enumValues": null, "fields": null, "inputFields": null, "interfaces": null, "kind": "SCALAR", "name": "Boolean", "possibleTypes": null }, { "description": "Categories are the containers for live streaming content.", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "Name of the category", "isDeprecated": false, "name": "name", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Slug of the category", "isDeprecated": false, "name": "slug", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "after", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "before", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "first", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "last", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "subcategories", "type": { "kind": "OBJECT", "name": "SubcategoryConnection", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "after", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "before", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "first", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "last", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "tags", "type": { "kind": "OBJECT", "name": "TagConnection", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "Category", "possibleTypes": null }, { "description": "A channel is a user\'s actual container for live streaming.", "enumValues": null, "fields": [ { "args": [ { "defaultValue": null, "description": null, "name": "after", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "before", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "first", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "last", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "bans", "type": { "kind": "OBJECT", "name": "ChannelBanConnection", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Toggle for blocking anyone from posting links", "isDeprecated": false, "name": "blockLinks", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "category", "type": { "kind": "OBJECT", "name": "Category", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "chatBgUrl", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "after", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "before", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "first", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "last", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "chatMessages", "type": { "kind": "OBJECT", "name": "ChatMessageConnection", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "chatRulesHtml", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "chatRulesMd", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Toggle for links automatically being clickable", "isDeprecated": false, "name": "disableHyperlinks", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "hmacKey", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "inaccessible", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "The language a user can expect in the stream", "isDeprecated": false, "name": "language", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "If the streamer has flagged this channel as only appropriate for Mature Audiences", "isDeprecated": false, "name": "matureContent", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Minimum account age length before chatting", "isDeprecated": false, "name": "minimumAccountAge", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "after", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "before", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "first", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "last", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "moderationLogs", "type": { "kind": "OBJECT", "name": "ChannelModerationLogConnection", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "after", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "before", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "first", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "last", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "moderators", "type": { "kind": "OBJECT", "name": "ChannelModeratorConnection", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "posterUrl", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Toggle for requiring confirmed email before chatting", "isDeprecated": false, "name": "requireConfirmedEmail", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Toggle for homepage visibility", "isDeprecated": false, "name": "showOnHomepage", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "showRecentChatMessagesOnly", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "The current status of the channnel", "isDeprecated": false, "name": "status", "type": { "kind": "ENUM", "name": "ChannelStatus", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "If the channel is live, this will be the current Stream", "isDeprecated": false, "name": "stream", "type": { "kind": "OBJECT", "name": "Stream", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "streamKey", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "streamer", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } }, { "args": [ { "defaultValue": null, "description": null, "name": "after", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "before", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "first", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "last", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "streams", "type": { "kind": "OBJECT", "name": "StreamConnection", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "subcategory", "type": { "kind": "OBJECT", "name": "Subcategory", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "tags", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "Tag", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "The title of the channel", "isDeprecated": false, "name": "title", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "Channel", "possibleTypes": null }, { "description": "A channel timeout or ban", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "channel", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "Channel", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "expiresAt", "type": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "reason", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "user", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "ChannelBan", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "count", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "edges", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "ChannelBanEdge", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "pageInfo", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "PageInfo", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "ChannelBanConnection", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "cursor", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "node", "type": { "kind": "OBJECT", "name": "ChannelBan", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "ChannelBanEdge", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "count", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "edges", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "ChannelEdge", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "pageInfo", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "PageInfo", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "ChannelConnection", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "cursor", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "node", "type": { "kind": "OBJECT", "name": "Channel", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "ChannelEdge", "possibleTypes": null }, { "description": "A moderation event that happened", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "action", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "channel", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "Channel", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "moderator", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "user", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "ChannelModerationLog", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "count", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "edges", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "ChannelModerationLogEdge", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "pageInfo", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "PageInfo", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "ChannelModerationLogConnection", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "cursor", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "node", "type": { "kind": "OBJECT", "name": "ChannelModerationLog", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "ChannelModerationLogEdge", "possibleTypes": null }, { "description": "A channel moderator", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "canBan", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "canDelete", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "canLongTimeout", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "canShortTimeout", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "canUnTimeout", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "canUnban", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "channel", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "Channel", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "user", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "ChannelModerator", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "count", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "edges", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "ChannelModeratorEdge", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "pageInfo", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "PageInfo", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "ChannelModeratorConnection", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "cursor", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "node", "type": { "kind": "OBJECT", "name": "ChannelModerator", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "ChannelModeratorEdge", "possibleTypes": null }, { "description": null, "enumValues": [ { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "LIVE" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "OFFLINE" } ], "fields": null, "inputFields": null, "interfaces": null, "kind": "ENUM", "name": "ChannelStatus", "possibleTypes": null }, { "description": "A chat message sent to a channel by a user.", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "channel", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "Channel", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": "We\'re going to replace this shortly after launch", "description": "Was this message generated by our system for a follow", "isDeprecated": true, "name": "isFollowedMessage", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": "We\'re going to replace this shortly after launch", "description": "Was this message generated by our system for a subscription", "isDeprecated": true, "name": "isSubscriptionMessage", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "The chat message contents, be careful to sanitize because any user input is allowed", "isDeprecated": false, "name": "message", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "tokens", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "INTERFACE", "name": "ChatMessageToken", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "user", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "ChatMessage", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "count", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "edges", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "ChatMessageEdge", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "pageInfo", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "PageInfo", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "ChatMessageConnection", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "cursor", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "node", "type": { "kind": "OBJECT", "name": "ChatMessage", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "ChatMessageEdge", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": null, "inputFields": [ { "defaultValue": null, "description": null, "name": "message", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "interfaces": null, "kind": "INPUT_OBJECT", "name": "ChatMessageInput", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "text", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "type", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "INTERFACE", "name": "ChatMessageToken", "possibleTypes": [ { "kind": "OBJECT", "name": "EmoteToken", "ofType": null }, { "kind": "OBJECT", "name": "TextToken", "ofType": null }, { "kind": "OBJECT", "name": "UrlToken", "ofType": null } ] }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "src", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "text", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "type", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "inputFields": null, "interfaces": [ { "kind": "INTERFACE", "name": "ChatMessageToken", "ofType": null } ], "kind": "OBJECT", "name": "EmoteToken", "possibleTypes": null }, { "description": "A follower is a user who subscribes to notifications for a particular user\'s channel.", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "hasLiveNotifications", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "streamer", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "user", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "Follower", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "count", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "edges", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "FollowerEdge", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "pageInfo", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "PageInfo", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "FollowerConnection", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "cursor", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "node", "type": { "kind": "OBJECT", "name": "Follower", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "FollowerEdge", "possibleTypes": null }, { "description": "The `ID` scalar type represents a unique identifier, often used to\\nrefetch an object or as key for a cache. The ID type appears in a JSON\\nresponse as a String; however, it is not intended to be human-readable.\\nWhen expected as an input type, any string (such as `\\"4\\"`) or integer\\n(such as `4`) input value will be accepted as an ID.", "enumValues": null, "fields": null, "inputFields": null, "interfaces": null, "kind": "SCALAR", "name": "ID", "possibleTypes": null }, { "description": "The `Int` scalar type represents non-fractional signed whole numeric values.\\nInt can represent values between `-(2^53 - 1)` and `2^53 - 1` since it is\\nrepresented in JSON as double-precision floating point numbers specified\\nby [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).", "enumValues": null, "fields": null, "inputFields": null, "interfaces": null, "kind": "SCALAR", "name": "Int", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [ { "defaultValue": null, "description": null, "name": "channelId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "defaultValue": null, "description": null, "name": "userId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } } ], "deprecationReason": null, "description": "Ban a user from a chat channel.", "isDeprecated": false, "name": "banUser", "type": { "kind": "OBJECT", "name": "ChannelModerationLog", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "channelId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "defaultValue": null, "description": null, "name": "message", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "INPUT_OBJECT", "name": "ChatMessageInput", "ofType": null } } } ], "deprecationReason": null, "description": "Create a chat message", "isDeprecated": false, "name": "createChatMessage", "type": { "kind": "OBJECT", "name": "ChatMessage", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "channelId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "defaultValue": null, "description": null, "name": "messageId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } } ], "deprecationReason": null, "description": "Deletes a specific chat message from channel.", "isDeprecated": false, "name": "deleteChatMessage", "type": { "kind": "OBJECT", "name": "ChannelModerationLog", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "streamId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } } ], "deprecationReason": null, "description": "End a stream", "isDeprecated": false, "name": "endStream", "type": { "kind": "OBJECT", "name": "Stream", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "metadata", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "INPUT_OBJECT", "name": "StreamMetadataInput", "ofType": null } } }, { "defaultValue": null, "description": null, "name": "streamId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } } ], "deprecationReason": null, "description": "Update a stream\'s metadata", "isDeprecated": false, "name": "logStreamMetadata", "type": { "kind": "OBJECT", "name": "Stream", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "channelId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "defaultValue": null, "description": null, "name": "userId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } } ], "deprecationReason": null, "description": "Long timeout (15 minutes) a user from a chat channel.", "isDeprecated": false, "name": "longTimeoutUser", "type": { "kind": "OBJECT", "name": "ChannelModerationLog", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "channelId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "defaultValue": null, "description": null, "name": "userId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } } ], "deprecationReason": null, "description": "Short timeout (5 minutes) a user from a chat channel.", "isDeprecated": false, "name": "shortTimeoutUser", "type": { "kind": "OBJECT", "name": "ChannelModerationLog", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "channelId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } } ], "deprecationReason": null, "description": "Start a stream", "isDeprecated": false, "name": "startStream", "type": { "kind": "OBJECT", "name": "Stream", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "channelId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "defaultValue": null, "description": null, "name": "userId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } } ], "deprecationReason": null, "description": "Unban a user from a chat channel.", "isDeprecated": false, "name": "unbanUser", "type": { "kind": "OBJECT", "name": "ChannelModerationLog", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "streamId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "defaultValue": null, "description": null, "name": "thumbnail", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "Upload", "ofType": null } } } ], "deprecationReason": null, "description": "Update a stream\'s thumbnail", "isDeprecated": false, "name": "uploadStreamThumbnail", "type": { "kind": "OBJECT", "name": "Stream", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "RootMutationType", "possibleTypes": null }, { "description": "The `Naive DateTime` scalar type represents a naive date and time without\\ntimezone. The DateTime appears in a JSON response as an ISO8601 formatted\\nstring.", "enumValues": null, "fields": null, "inputFields": null, "interfaces": null, "kind": "SCALAR", "name": "NaiveDateTime", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": "When paginating forwards, the cursor to continue.", "isDeprecated": false, "name": "endCursor", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "When paginating forwards, are there more items?", "isDeprecated": false, "name": "hasNextPage", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "When paginating backwards, are there more items?", "isDeprecated": false, "name": "hasPreviousPage", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "When paginating backwards, the cursor to continue.", "isDeprecated": false, "name": "startCursor", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "PageInfo", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": "List all categories", "isDeprecated": false, "name": "categories", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "Category", "ofType": null } } }, { "args": [ { "defaultValue": null, "description": null, "name": "slug", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "deprecationReason": null, "description": "Query individual category", "isDeprecated": false, "name": "category", "type": { "kind": "OBJECT", "name": "Category", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "defaultValue": null, "description": null, "name": "streamerId", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "streamerUsername", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "deprecationReason": null, "description": "Query individual channel", "isDeprecated": false, "name": "channel", "type": { "kind": "OBJECT", "name": "Channel", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "after", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "before", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "categorySlug", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "first", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "last", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "status", "type": { "kind": "ENUM", "name": "ChannelStatus", "ofType": null } } ], "deprecationReason": null, "description": "List all channels", "isDeprecated": false, "name": "channels", "type": { "kind": "OBJECT", "name": "ChannelConnection", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "after", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "before", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "first", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "last", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "streamerId", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "userId", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } } ], "deprecationReason": null, "description": "List all follows or followers", "isDeprecated": false, "name": "followers", "type": { "kind": "OBJECT", "name": "FollowerConnection", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Get yourself", "isDeprecated": false, "name": "myself", "type": { "kind": "OBJECT", "name": "User", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "id", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "username", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "deprecationReason": null, "description": "Query individual user", "isDeprecated": false, "name": "user", "type": { "kind": "OBJECT", "name": "User", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "after", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "before", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "first", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "last", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } } ], "deprecationReason": null, "description": "List all users", "isDeprecated": false, "name": "users", "type": { "kind": "OBJECT", "name": "UserConnection", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "RootQueryType", "possibleTypes": null }, { "description": "A stream is a single live stream in, either current or historical.", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "category", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "Category", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "channel", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "Channel", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "Concurrent viewers during last snapshot", "isDeprecated": false, "name": "countViewers", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Datetime of when the stream was ended, or null if still going", "isDeprecated": false, "name": "endedAt", "type": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [ { "defaultValue": null, "description": null, "name": "after", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "before", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "first", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "last", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "metadata", "type": { "kind": "OBJECT", "name": "StreamMetadataConnection", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Peak concurrent viewers", "isDeprecated": false, "name": "peakViewers", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Datetime of when the stream was started", "isDeprecated": false, "name": "startedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "thumbnailUrl", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "The title of the channel when the stream was started", "isDeprecated": false, "name": "title", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "Stream", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "count", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "edges", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "StreamEdge", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "pageInfo", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "PageInfo", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "StreamConnection", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "cursor", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "node", "type": { "kind": "OBJECT", "name": "Stream", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "StreamEdge", "possibleTypes": null }, { "description": "A single instance of stream metadata.", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "audioCodec", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "ingestServer", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "ingestViewers", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "lostPackets", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "nackPackets", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "recvPackets", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "sourceBitrate", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "sourcePing", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "stream", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "Stream", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "streamTimeSeconds", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "vendorName", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "vendorVersion", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "videoCodec", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "videoHeight", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "videoWidth", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "StreamMetadata", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "count", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "edges", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "StreamMetadataEdge", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "pageInfo", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "PageInfo", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "StreamMetadataConnection", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "cursor", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "node", "type": { "kind": "OBJECT", "name": "StreamMetadata", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "StreamMetadataEdge", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": null, "inputFields": [ { "defaultValue": null, "description": null, "name": "audioCodec", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "ingestServer", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "ingestViewers", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "lostPackets", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "nackPackets", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "recvPackets", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "sourceBitrate", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "sourcePing", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "streamTimeSeconds", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "vendorName", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "vendorVersion", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "videoCodec", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "videoHeight", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "videoWidth", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } } ], "interfaces": null, "kind": "INPUT_OBJECT", "name": "StreamMetadataInput", "possibleTypes": null }, { "description": "The `String` scalar type represents textual data, represented as UTF-8\\ncharacter sequences. The String type is most often used by GraphQL to\\nrepresent free-form human-readable text.", "enumValues": null, "fields": null, "inputFields": null, "interfaces": null, "kind": "SCALAR", "name": "String", "possibleTypes": null }, { "description": "Subcategories are specific games, topics, or genre\'s that exist under a Category.", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "backgroundImageUrl", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "category", "type": { "kind": "OBJECT", "name": "Category", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "Name of the subcategory", "isDeprecated": false, "name": "name", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "URL friendly name of the subcategory", "isDeprecated": false, "name": "slug", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "source", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "sourceId", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "userCreated", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "Subcategory", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "count", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "edges", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "SubcategoryEdge", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "pageInfo", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "PageInfo", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "SubcategoryConnection", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "cursor", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "node", "type": { "kind": "OBJECT", "name": "Subcategory", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "SubcategoryEdge", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [ { "defaultValue": null, "description": null, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "channel", "type": { "kind": "OBJECT", "name": "Channel", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "channelId", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "chatMessage", "type": { "kind": "OBJECT", "name": "ChatMessage", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "streamerId", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "followers", "type": { "kind": "OBJECT", "name": "Follower", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "RootSubscriptionType", "possibleTypes": null }, { "description": "Tags are user created labels that are either global or category specific.", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "category", "type": { "kind": "OBJECT", "name": "Category", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "The number of streams started with this tag", "isDeprecated": false, "name": "countUsage", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "Name of the tag", "isDeprecated": false, "name": "name", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "URL friendly name of the tag", "isDeprecated": false, "name": "slug", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "Tag", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "count", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "edges", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "TagEdge", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "pageInfo", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "PageInfo", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "TagConnection", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "cursor", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "node", "type": { "kind": "OBJECT", "name": "Tag", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "TagEdge", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "text", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "type", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "inputFields": null, "interfaces": [ { "kind": "INTERFACE", "name": "ChatMessageToken", "ofType": null } ], "kind": "OBJECT", "name": "TextToken", "possibleTypes": null }, { "description": "Represents an uploaded file.", "enumValues": null, "fields": null, "inputFields": null, "interfaces": null, "kind": "SCALAR", "name": "Upload", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "text", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "type", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "url", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "inputFields": null, "interfaces": [ { "kind": "INTERFACE", "name": "ChatMessageToken", "ofType": null } ], "kind": "OBJECT", "name": "UrlToken", "possibleTypes": null }, { "description": "A user of Glimesh, can be a streamer, a viewer or both!", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "allowGlimeshNewsletterEmails", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "allowLiveSubscriptionEmails", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "URL to the user\'s avatar", "isDeprecated": false, "name": "avatarUrl", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "A user\'s channel, if they have one", "isDeprecated": false, "name": "channel", "type": { "kind": "OBJECT", "name": "Channel", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Datetime the user confirmed their email address", "isDeprecated": false, "name": "confirmedAt", "type": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "countFollowers", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "countFollowing", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Exactly the same as the username, but with casing the user prefers", "isDeprecated": false, "name": "displayname", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "String", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "Email for the user, hidden behind a scope", "isDeprecated": false, "name": "email", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "after", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "before", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "first", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "last", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "followers", "type": { "kind": "OBJECT", "name": "FollowerConnection", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "after", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "before", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "first", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "last", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "following", "type": { "kind": "OBJECT", "name": "FollowerConnection", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "after", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "before", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "first", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "last", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } } ], "deprecationReason": null, "description": "Shortcut to a user\'s followed channels", "isDeprecated": false, "name": "followingLiveChannels", "type": { "kind": "OBJECT", "name": "ChannelConnection", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "Account creation date", "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "HTML version of the user\'s profile, should be safe for rendering directly", "isDeprecated": false, "name": "profileContentHtml", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Markdown version of the user\'s profile", "isDeprecated": false, "name": "profileContentMd", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Qualified URL for the user\'s Discord server", "isDeprecated": false, "name": "socialDiscord", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Qualified URL for the user\'s Guilded server", "isDeprecated": false, "name": "socialGuilded", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Qualified URL for the user\'s Instagram account", "isDeprecated": false, "name": "socialInstagram", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Qualified URL for the user\'s YouTube account", "isDeprecated": false, "name": "socialYoutube", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "A list of linked social accounts for the user", "isDeprecated": false, "name": "socials", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "UserSocial", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "The primary role the user performs on the Glimesh team", "isDeprecated": false, "name": "teamRole", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Account last updated date", "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "Lowercase user identifier", "isDeprecated": false, "name": "username", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "String", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "YouTube Intro URL for the user\'s profile", "isDeprecated": false, "name": "youtubeIntroUrl", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "User", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "count", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "edges", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "UserEdge", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "pageInfo", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "PageInfo", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "UserConnection", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "cursor", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "node", "type": { "kind": "OBJECT", "name": "User", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "UserEdge", "possibleTypes": null }, { "description": "A linked social account for a Glimesh user.", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "Platform unique identifier, usually a ID, made into a string", "isDeprecated": false, "name": "identifier", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "Platform that is linked, eg: twitter", "isDeprecated": false, "name": "platform", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "Username for the user on the linked platform", "isDeprecated": false, "name": "username", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "UserSocial", "possibleTypes": null } ] } } } }); // Sets the settings to a dark color // var menuThingy = document.getElementsByClassName("menu-content"); // menuThingy[0].style.backgroundColor = "#0e1726"; // Sets the navbar to the left. Doesn\'t do much, just gives appearance of more space. // var navBar = document.getElementsByTagName("nav"); // navBar[0].style.left = 0; // dark colors // var voyagerPanel = document.getElementsByClassName("doc-navigation"); //voyagerPanel[0].style.background = "#0e1726" // var voyagerPanel = document.getElementsByClassName("scroll-area"); // voyagerPanel[0].style.background = "#0e1726"; // var voyagerPanel = document.getElementsByClassName("contents"); // voyagerPanel[0].style.background = "#0e1726" // var voyagerPanel = document.getElementsByClassName("doc-panel"); // voyagerPanel[0].style.position = "absolute" // Makes the panel draggable, hopefully users will move it to a better position. // dragElement(voyagerPanel[0]); function dragElement(elmnt) { var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; elmnt.onmousedown = dragMouseDown; function dragMouseDown(e) { e = e || window.event; e.preventDefault(); // get the mouse cursor position at startup: pos3 = e.clientX; pos4 = e.clientY; document.onmouseup = closeDragElement; // call a function whenever the cursor moves: document.onmousemove = elementDrag; } function elementDrag(e) { e = e || window.event; e.preventDefault(); // calculate the new cursor position: pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY; pos3 = e.clientX; pos4 = e.clientY; // set the element\'s new position: elmnt.style.top = (elmnt.offsetTop - pos2) + "px"; elmnt.style.left = (elmnt.offsetLeft - pos1) + "px"; } function closeDragElement() { // stop moving when mouse button is released: document.onmouseup = null; document.onmousemove = null; } }  '}),a.add({id:11,href:'/api-docs/docs/authentication/accesstoken/accesstoken/',title:"Access Token",section:"Access Token",content:"Access Tokens #  An access token can be used to query the Glimesh API on behalf of a user. You can also get info about the user that the token belongs to.\n This guide is for getting a token from a real user. If you are just testing or don\u0026rsquo;t want to setup authentication yet you can use client credentials\n Requesting A Token #  Before requesting a token you must have a developer application. You will need your client ID, secret ID, and redirect URL. First you need to have a user authenticate with your app. The user must be directed to\nhttps://glimesh.tv/oauth/authorize?response_type=code\u0026amp;state=\u0026amp;client_id=CLIENT_ID\u0026amp;scope=public%20email%20chat%20streamkey\u0026amp;redirect_uri=REDIRECT_URL Make sure to replace your client ID and your redirect URL. The redirect URL must match one of the URL\u0026rsquo;s on your application. Scopes are space separated values that determine what permissions you want from the user. Only request the scopes that you need.\nThe current scopes are:\n public: Get public information about the user and other users on Glimesh. email: View the email of the user. chat: View and speak in a chatroom. stream View the streamkey of the user.  When the user is sent to the link they will have to accept your app scopes. They will then be sent to your apps redirect URL. Glimesh will send a code inside the URL when they are sent back to your app. You need to extract it from the URL.\nhttp://your-app.com/some/area?code=qwertyuiop123 Once you have the code you need to make a request to Glimesh. We will exchange the code for an access token.\nPOST https://glimesh.tv/api/oauth/token?grant_type=authorization_code\u0026amp;code=CODE\u0026amp;redirect_uri=REDIRECT_URL\u0026amp;client_id=CLIENTID\u0026amp;client_secret=SECRETID Send a POST request with the URL above replacing the code,redirect url, client ID, and secret ID. Remember to keep the secret ID hidden from your users. When Glimesh receives the POST request it will send back the information we want. Once it is parsed it will look like this:\n{ access_token: \u0026#39;qwertyuiopo1234567890\u0026#39;, created_at: \u0026#39;2020-12-14T15:15:29\u0026#39;, expires_in: 21600, refresh_token: \u0026#39;qwertyuiop0987654321\u0026#39;, scope: \u0026#39;public email chat streamkey\u0026#39;, token_type: \u0026#39;bearer\u0026#39; } Now you can query the Glimesh API on behalf of a user. This token will expire after a few hours so you need to refresh it or ask the user for a new one. If you have any questions talk to us in the #dev-questions channel in our Discord.\n Ready to refresh your token? Continue with OAuth here\n Common Errors #  There are a few errors you may encounter while requesting a token.\n{ error: \u0026#39;invalid_grant\u0026#39;, error_description: \u0026#39;The provided authorization grant is invalid, expired, revoked, does not match the redirection URI used in the authorization request, or was issued to another client.\u0026#39; } This means something is wrong with your URL. You can only use each code once. You must send the request with the grant_type=authorization_code for Glimesh to send you the access token. Ensure all of the data in the URL matches the data in your dev application. Glimesh will refuse any request that is not properly formatted.\n{ error: \u0026#39;invalid_request\u0026#39;, error_description: \u0026#39;The request is missing a required parameter, includes an unsupported parameter value, or is otherwise malformed.\u0026#39; } This is a request error. Some part of your URL is not necessary or missing. Ensure the parameters in the URL are spelled correctly. You should also check that you have all of the required data in the URL.\nError: 401 Unauthorized. You must be logged in to access the API.\nThis is an authentication issue. This is commonly seen when querying the API but I added it here because it most likely means you must request another token. You must renew or request a new token and send the API request to Glimesh properly. Tokens expire after a few hours unless they are renewed.\n Stuck with something? Talk to us in Discord. We would be happy to help you!\n "}),a.add({id:12,href:'/api-docs/docs/authentication/accesstoken/nodejs/node-access-token/',title:"Node Access Token",section:"Access Token",content:"Getting User Tokens With NodeJS #  This is a basic tutorial for getting an auth token from a user using Oauth with NodeJS. This guide assumes you know basic JS and understand the workings of Oauth 2.\n Need a refresh? This tutorial explains the basics of Oauth 2 https://darutk.medium.com/the-simplest-guide-to-oauth-2-0-8c71bd9a15bb\n Creating the Project #  We need to create a basic project. In your terminal type:\nnpm init -y\nThis will create a project.JSON file. This project uses the Express and Request packages. Install them with:\nnpm install express request\nThese packages will help us set up a basic web server and send requests to Glimesh.\nStarting Up #  In your project create a blank JS file. I will title mine auth.js. Start by importing Express. Paste this at the top of your file.\nconst express = require(\u0026#39;express\u0026#39;); //Express package const app = express(); // Creates endpoints for the server. const request = require(\u0026#39;request\u0026#39;); //Request package var clientID = \u0026#34;\u0026#34;; // ID for connecting your users to your app. var secretID = \u0026#34;\u0026#34;; //ID to verify your app, keep private. var redirectUri = \u0026#34;http://localhost:3000/success\u0026#34;; //The redirect path you want to encode into the auth request This imports the modules our server will need. The server will use the app variable for creating endpoints. The IDs are used so Glimesh can identify our app. We will insert the IDs later.\nCreating the server #  First we need to tell the server to listen for connections. We also need to tell the server which port to be on. I would recommend 8080 or 3000. Paste this in your file:\nconst port = process.env.PORT || 3000; //Opens the server on port 3000 app.listen(port, () =\u0026gt; console.log(\u0026#39;App listening on port \u0026#39; + port)); //keeps the server running^ This will keep the server from closing by itself. Now we can create endpoints for our users to connect to. One will redirect to the Glimesh auth page (/oauth/authorize) and the other will handle the auth info sent from Glimesh. You can create a web page for the first endpoint if you wish. For the sake of this tutorial I will keep it a simple redirect. Paste this in your file:\n//When a user visits http://localhost:3000/auth app.get(\u0026#39;/auth\u0026#39;, (req, res) =\u0026gt; { //redirects the user to the glimesh authenication page res.redirect(307, \u0026#39;https://glimesh.tv/oauth/authorize?response_type=code\u0026amp;state=\u0026amp;client_id=\u0026#39; + clientID + \u0026#39;\u0026amp;scope=public%20email%20chat%20streamkey\u0026amp;redirect_uri=\u0026#39; + encodeURIComponent(redirectUri)); }); In this URL we send the client ID, the redirect URL, and a set of scopes that we want access to. We also request a code in the response_type. Next we will create a developer application. This will give us a client ID and a secret ID.\n If you have a web page that you want your users to access when they go to this endpoint you can send it to them by using res.sendFile(\u0026quot;FILE_NAME.html\u0026quot;) You would need to have a button or other method to send them to the authentication page.\n Developer Applications #  Before we can request Oauth permissions we need a developer application. This is what Glimesh will use to authenticate users for your app. It is also how Glimesh can monitor and identify requests you and your users send. Click here to create your developer application.\nSet up your dev application like this. Use a unique name and description. You can update these at any time. Ensure that the homepage of your app is http://localhost:3000 and your redirect link is http://localhost:3000/success. You must replace the port number if you used a different port.\nSave your app when you are finished.\nGetting the Token #  Now that we have a developer app we can update our variables. Set it equal to your client ID and secret ID. It is very important to keep the secret ID hidden from your users. If your ID is leaked you can reset them from the Glimesh dev app page but your users must authenticate again.\nvar clientID = \u0026#34;CLIENT_ID_HERE\u0026#34; var secretID = \u0026#34;SECRET_HERE\u0026#34; We need to create an endpoint for Glimesh to redirect to. In the previous section we told Glimesh to redirect to locahhost:3000/success. Let\u0026rsquo;s create it!\napp.get(\u0026#34;/success\u0026#34;, (req, res) =\u0026gt; { let code = req.query.code; console.log(\u0026#34;The code is \u0026#34; + code); res.send(`\u0026lt;h1\u0026gt;code recieved!\u0026lt;/h1\u0026gt;`) //Sends a confirmation message to the user }); When our user is redirected to our server the token is sent in the URL as ?code=CODE_HERE. We pull the code from URL and log it to the console.\nOnce you have the code you can request the token from Glimesh. This can be done with a simple Request function. When we get a response we parse it and log it to the console. Update the code for the /success endpoint as follows:\napp.get(\u0026#34;/success\u0026#34;, (req, res) =\u0026gt; { let code = req.query.code; console.log(\u0026#34;The code is \u0026#34; + code); res.send(`\u0026lt;h1\u0026gt;Code recieved, requesting token!\u0026lt;/h1\u0026gt;`) //Sends a confirm message to the user  //Now we send this code to Glimesh to ask for a token.  var options = { method: \u0026#39;POST\u0026#39;, body: \u0026#34;\u0026#34;, url: \u0026#34;https://glimesh.tv/api/oauth/token?grant_type=authorization_code\u0026amp;code=\u0026#34; + code + \u0026#34;\u0026amp;redirect_uri=\u0026#34; + encodeURIComponent(redirectUri) + \u0026#34;\u0026amp;client_id=\u0026#34; + clientID + \u0026#34;\u0026amp;client_secret=\u0026#34; + secretID }; request(options, (error, response, body) =\u0026gt; { if (!error \u0026amp;\u0026amp; response.statusCode == 200) { //If all is as it should be  console.log(body); //The unfiltered response  var data = JSON.parse(body); console.log(data) } else { console.log(error) //log any errors  console.log(response.statusCode) console.log(body) } }); }); Save the file when you are finished. Let\u0026rsquo;s test our code! In your terminal type:\nnode FILE_NAME.js\nReplace FILE_NAME with the name of your file. This will start up the web server. Some antivirus programs may block the process because other devices on your network can access this server. Simply allow the port number you used in your antivirus software if this is the case. You may want to restart the server.\nOnce that is complete and the server is running head to http://localhost:3000/auth replacing the port number with the correct port. It will redirect you to your client application page. Accept it and it will redirect you back to your server at the /success endpoint.\n Please note that you must be logged in before authorizing. A bug prevents you from entering your account info and proceeding to the client app screen. If you are not logged in you must sign in and then go back to /auth\n You should see a confirmation message in your browser. The server is now sending the code back to Glimesh to request a token. Check the console in your terminal to see the code!\nYou can use the access_token to query the API on the users behalf. This will expire after a few hours so you will need to refresh the token or get a new one. If you have any question talk to us in the #dev-questions channel in our Discord. We would love to hear what you are making!\nThe full file can be found here.\nconst express = require(\u0026#39;express\u0026#39;); //Express package const app = express(); // Creates endpoints for the server. const request = require(\u0026#39;request\u0026#39;); //Request package var clientID = \u0026#34;\u0026#34;; // ID for connecting your users to your app. var secretID = \u0026#34;\u0026#34;; //ID to verify your app, keep private. var redirectUri = \u0026#34;http://localhost:3000/success\u0026#34;; //The redirect path you want to encode into the auth request  const port = process.env.PORT || 3000; //Opens the server on port 3000 app.listen(port, () =\u0026gt; console.log(\u0026#39;App listening on port \u0026#39; + port)); //keeps the server running^  //When a user visits http://localhost:3000/auth app.get(\u0026#39;/auth\u0026#39;, (req, res) =\u0026gt; { //redirects the user to the glimesh authenication page 	res.redirect(307, \u0026#39;https://glimesh.tv/oauth/authorize?response_type=code\u0026amp;state=\u0026amp;client_id=\u0026#39; + clientID + \u0026#39;\u0026amp;scope=public%20email%20chat%20streamkey\u0026amp;redirect_uri=\u0026#39; + encodeURIComponent(redirectUri)); }); app.get(\u0026#34;/success\u0026#34;, (req, res) =\u0026gt; { let code = req.query.code; console.log(\u0026#34;The code is \u0026#34; + code); res.send(`\u0026lt;h1\u0026gt;Code Recieved!\u0026lt;/h1\u0026gt;`) //Sends a confirm message to the user 	//Now we send this code to Glimesh to ask for a token. 	var options = { method: \u0026#39;POST\u0026#39;, body: \u0026#34;\u0026#34;, url: \u0026#34;https://glimesh.tv/api/oauth/token?grant_type=authorization_code\u0026amp;code=\u0026#34; + code + \u0026#34;\u0026amp;redirect_uri=\u0026#34; + encodeURIComponent(redirectUri) + \u0026#34;\u0026amp;client_id=\u0026#34; + clientID + \u0026#34;\u0026amp;client_secret=\u0026#34; + secretID }; request(options, (error, response, body) =\u0026gt; { //Send glimesh the code for a token in return 	if (!error \u0026amp;\u0026amp; response.statusCode == 200) { //If all is as it should be 	console.log(body); //The unfiltered response 	var data = JSON.parse(body); //The parsed response 	console.log(data) // The data we want! 	} else { console.log(error) //log any errors 	console.log(response.statusCode) //Status code if an error occurs 	console.log(body) //The body for more info 	} }); }); "}),a.add({id:13,href:'/api-docs/docs/authentication/refreshtoken/refreshtoken/',title:"Refresh Token",section:"Refresh Token",content:"Refresh Tokens #  A refresh token allows you to get a new access token without having your user authenticate again. It is a standard part of OAuth 2.\n Looking for authentication flow? Start with access tokens\n Refreshing A Token #  Refresh tokens are sent when you request an access token. You can pull them from the data that Glimesh sends you.\n{ access_token: \u0026#39;qwertyuiopo1234567890\u0026#39;, created_at: \u0026#39;2020-12-14T15:15:29\u0026#39;, expires_in: 21600, refresh_token: \u0026#39;qwertyuiop0987654321\u0026#39;, scope: \u0026#39;public email chat streamkey\u0026#39;, token_type: \u0026#39;bearer\u0026#39; } You can refresh a token at any time. You do not need to wait for the access token to expire. Refresh tokens last for about one year. When you refresh a token you will need all the info from when you requested an access token.\nSend a POST request to:\nhttps://glimesh.tv/api/oauth/token?grant_type=refresh_token\u0026amp;refresh_token=REFRESH_TOKEN\u0026amp;redirect_uri=REDIRECT_URL\u0026amp; client_id=CLIENT_ID\u0026amp;client_secret=SECRET_ID Make sure to replace REFRESH_TOKEN, REDIRECT_URL, CLIENT_ID, and SECRET_ID with their corresponding values. They must match the values that were sent when you requested an access token. If you want new scopes you must request a new token.\nProvided you formatted your request correctly Glimesh will send you back a new refresh token and access token.\n{ \u0026#34;access_token\u0026#34;: \u0026#34;qwertyuioip123456789\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2020-12-21T23:08:22\u0026#34;, \u0026#34;expires_in\u0026#34;: 21600, \u0026#34;refresh_token\u0026#34;: \u0026#34;qwertyuiop098765321\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;public email chat streamkey\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34; } This will allow you to use the new token and continue to query the Glimesh API. You must use the new access token and the new refresh token. You can safely discard the old tokens.\nOther Info #   You cannot get new scopes from refresh tokens. You must make the user authenticate again with the new scopes. Access tokens last for about 6 hours. You can refresh them earlier if needed. Refresh tokens last for about 1 year. If a user revokes your dev app you cannot use the access or refresh tokens. This would require the user to authenticate again.  If you have any questions talk to us in the #dev-questions channel in our Discord.\n"}),a.add({id:14,href:'/api-docs/docs/chat/chat-tokens/',title:"Chat Tokens",section:"Chat",content:"Chat Tokens #  Chat tokens are a different way to handle messages sent from chat. A normal message is just a simple string. A chat token is an array of data that shows you all sorts of information about the message and what it contains.\n This is a continuation of the websocket tutorial. If you have not already completed the tutorial you can do so here. A chat connection is required for this tutorial.\n The Basics #  A chat token is the original message split by several factors.\n Normal text Emotes URL\u0026rsquo;s  Using the token property we can identify information we would previously have had to parse. Normal text is exactly what is sounds like. Emotes are emotes from Glimesh. The URL is included as well as the text to create it :glimsmile: . URL\u0026rsquo;s are also detected separately from text. This information is also provided alongside the default message property. This means you don\u0026rsquo;t have to use chat tokens if you don\u0026rsquo;t want to.\nAs shown in the image above the chat parts contain all the data from the chat message. The original message is above the chat parts.\nBuilding The Query/Subscription #  We need to query chatMessage. We will plan for every possible type of data in a message. If you do not already have a working websocket for Glimesh you need to get one. If you don\u0026rsquo;t want to keep a connection open you can make a normal query to the channel and view the chatMessages property. Either method is valid.\nStart with this subscription\nsubscription{ chatMessage(channelId:6) { message, user { id }, tokens { ...on EmoteToken { src, text, type, }, ...on TextToken { text, type }, ...on UrlToken { text, type, url } } } } Or use a query.\nquery { channel(id: 6) { chatMessages(last: 5) { edges { node { message user { id } tokens { ... on EmoteToken { src text type } ... on TextToken { text type } ... on UrlToken { text type url } } } } } } }  Make sure to replace 6 with your channel ID!\n You don\u0026rsquo;t need to request every property, adjust the request as needed.\nThese requests will return the chat message as well as its message parts. The parts are in an array. The array values are generated if the message contains the type requested. If the type does not exist an array value is not generated.\nExample websocket response:\n[ null, null, \u0026#34;__absinthe__:doc:-576460752302054414:1C57C19163D4D59F61626243BCCA79AB4E50D5C4C2BD8BDA0DDCE83517B20C16\u0026#34;, \u0026#34;subscription:data\u0026#34;, { \u0026#34;result\u0026#34;:{ \u0026#34;data\u0026#34;:{ \u0026#34;chatMessage\u0026#34;:{ \u0026#34;message\u0026#34;:\u0026#34;Hello Glimesh Devs :glimsmile:\u0026#34;, \u0026#34;tokens\u0026#34;:[ { \u0026#34;text\u0026#34;:\u0026#34;Hello Glimesh Devs \u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;/emotes/svg/glimsmile.svg\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;:glimsmile:\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;emote\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;https://glimesh.tv/emotes/svg/glimsmile-af9a10c9d4c4181dbd87ab245d3e3bee.svg?vsn=d\u0026#34; } ] } } }, \u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752302054414:1C57C19163D4D59F61626243BCCA79AB4E50D5C4C2BD8BDA0DDCE83517B20C16\u0026#34; } ]  Message: Hello Glimesh Devs :glimsmile:\n Your response will vary slightly depending on the message and the query.\nFAQ #  Q: What happens if I use a nonexistent emote? :fake_emote:\n A: Glimesh will realize the emote is not real and detect it as text.\n Q: What is the difference between this and the normal chat API?\n A: This version is more advanced and all the parsing is done for you.\n Q: Should I switch to chat parts?\n A: That depends on your project. The normal chat API isn\u0026rsquo;t going away so you can use whichever method you like.\n If you have more questions feel free to talk to us in our discord!\n"}),a.add({id:15,href:'/api-docs/docs/chat/moderation/',title:"Moderation",section:"Chat",content:"Chat Moderation #  Using the Glimesh API we can use mod features such as timeouts and bans. These are critical for chatbots and other services. Before starting this tutorial you should have a working connection to the API and understand basic GraphQL.\n New to GraphQL? This tutorial explains the basics. https://graphql.org/learn/schema/\n  If you are looking for live updates related to moderation you can apply the queries in this tutorial to our Live Updates tutorial here.\n Understanding Mod Actions #  Glimesh has various methods to help streamers moderate their chat. All of the below methods are useable through the API.\n   Action Result     banUser Bans the user from the channel.   unbanUser Removes the ban on a user.   longTimeoutUser Prevents a user from typing for 15 minutes.   shortTimeoutUser Prevents a user from typing for 5 minutes.   deleteMessage Removes a message from chat.    To use any of these methods you must have the proper rank in the chat. You need to be a streamer or a moderator in their chat. You also need the user ID of the user who will receive the action and the channel ID of the channel in which the action will take place. You can get a channel ID with the below query.\nquery { channel(streamerUsername: \u0026#34;NAMEHERE\u0026#34;) { id } } A user ID can be attained from various queries. Since you are likely in a chat you can pull the ID from the chatMessage event. Your subscription to a chat (to listen for chat messages) would look something like this.\nsubscription { chatMessage(channelId:6) { message, user { id } } } The message would be the chat message and the ID in the user object would be the ID of the user who sent the message.\n There is also an ID property in the chatMessage. This is the ID of the message, not a user or channel ID. Don\u0026rsquo;t get them confused!\n Connection #  Now that we have a method to get the user and channel IDs we can start banning everyone moderating!\n Memes aside, you always need to use the API responsibly. Bots, AI, and message parsing can fail and you never want to wrongly ban a user. Always ensure that any automated services log all their actions. You may need to go back and unban someone if a mistake is made.\n For testing purposes you should use your own channel and a bot account. You can ban yourself but it\u0026rsquo;s easier to use a different account. Glimesh uses mutations to moderate users. Mutations can be sent in http or websocket form. If you are in chat it is best to use the websocket since a connection would already be open.\nTimeouts #  Send this to the API to timeout a user for 5 minutes.\nmutation { shortTimeoutUser(channelId:6, userId:201) { action, moderator {displayname}, } }  You need to replace 6 and 201 with the proper IDs.\n A long timeout is very similar. This will last for 15 minutes.\nmutation { longTimeoutUser(channelId:6, userId:201) { action, moderator {displayname}, } } Bans #  Banning users works the same way. Simply replace the timeout mutation with the ban mutation.\nmutation { banUser(channelId:6, userId:201) { action, moderator {displayname} } } If you need to unban a user you can use this mutation.\nmutation { unbanUser(channelId:6, userId:201) { action, moderator {displayname} } } Delete Messages #  You can also delete messages. You need the channel ID and the message ID. The message ID can be attained by querying the messages in a channel or by requesting it in a chatMessage subscription. Use this mutation to delete a message.\nmutation { deleteChatMessage(channelId:6, messageId: 111) { action, moderator { displayname } } } Attempting to unban a user that is not banned will return an internal server error. Attempting to use any moderator action on a user or message that does not exist will return \u0026ldquo;not found\u0026rdquo;. Using moderator actions in a channel that you do not have the authorization will result in an error. If you need more information about what properties you can receive from a moderator action check out the moderator reference. It provides a list of all the properties you can request. Glimesh.tv/api has a full list of all the API features.\nModeration Log #  Glimesh stores a copy of all the moderation events that happen to a user. This log can be viewed by the streamer here. We can also access this log via the API. Unlike the webpage, this log can be viewed by any user! Let\u0026rsquo;s create a basic query.\nquery { channel(id:6) { moderationLogs(last: 3) { edges { node { action, moderator {username} } } } } } This will return an array of data showing the moderation logs. Moderation logs are paginated, you can read more about that here\n{ \u0026#34;data\u0026#34;: { \u0026#34;channel\u0026#34;: { \u0026#34;moderationLogs\u0026#34;: { \u0026#34;edges\u0026#34;: [ { \u0026#34;node\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;delete_message\u0026#34;, \u0026#34;moderator\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } } }, { \u0026#34;node\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;delete_message\u0026#34;, \u0026#34;moderator\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;AFaithfulServant\u0026#34; } } }, { \u0026#34;node\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;delete_message\u0026#34;, \u0026#34;moderator\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } } } ] } } } } That is the basis for using moderation actions with the API. All of the above queries and mutations can be done through a websocket connection as well as a normal query.\nIf you have any questions talk to us in the #dev-questions channel in our Discord.\n"}),a.add({id:16,href:'/api-docs/docs/chat/mutations/',title:"Mutations",section:"Chat",content:"Chat Mutations #  This tutorial will enable you to query and send messages to the chat using the Glimesh API. If you are looking to build a chatbot or other program that needs a constant connection view this tutorial. To connect to a chat you will need an access token or a client ID. Keep in mind that using a client ID will keep you in read-only mode for chat environments. The access token must have the chat scope to post messages.\n If you are testing you can use client credentials to get an access token. This will allow you to talk as your own account without going through the entire auth process.\n Starting Up #  Since we are not using a websocket connection we have to manually query and send chat messages. This is done through the Glimesh API. We can query any channel for chat messages. We can also send messages to any channel that we choose. Understanding how API requests work will be important for completing this tutorial.\n New to the API? Read this before starting.\n Authentication #  All API requests must contain the proper authentication. The authentication value should be included as a header of the request. This value will change depending on the authentication type. For access tokens use:\nAuthorization: Bearer YOUR_TOKEN .\nReplace YOUR_TOKEN with your access token. If you are using a client ID to authenticate you must use this instead:\nAuthorization: Client-ID YOUR_CLIENT_ID\nReplace YOUR_CLIENT_ID with your ID. This will allow you access to the API.\n A client ID can only use the API in read only mode. An access token must have the chat scope.\n Querying Existing Messages #  We need to set up a query to gather the chat messages. You will need the channel ID of a streamer to get the messages. You can get a channel ID with this query. Replace Mytho with the name of the user that you want the ID from.\nquery { channel(streamerUsername: \u0026#34;Mytho\u0026#34;) { id } } Once you have the ID we can build our request. The query needs to be in the body of the request. You must send the query as a POST request. Structure it as follows:\nquery { channel(id: ID) { chatMessages(last: 10) { edges { node { message, user { username, avatarUrl } } } } } }  Don\u0026rsquo;t forget to replace ID with the channel ID! If you want more data you can view the chatMessage reference here Chat messages are paginated, you can read about that here\n Glimesh will respond with a set of JSON data. You need to parse it to get the data that you want.\n{ \u0026#34;data\u0026#34;: { \u0026#34;channel\u0026#34;: { \u0026#34;chatMessages\u0026#34;: { \u0026#34;edges\u0026#34;: [ { \u0026#34;node\u0026#34;: { \u0026#34;message\u0026#34;: \u0026#34;lee run the free truck in ovals bro no chance of rating loss and really gives you a good feeling \u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://glimesh-user-assets.nyc3.cdn.digitaloceanspaces.com/uploads/avatars/Sainted_Lord.png?v=63782488662\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Sainted_Lord\u0026#34; } } }, { \u0026#34;node\u0026#34;: { \u0026#34;message\u0026#34;: \u0026#34;You all make this game seem so awesome! D:\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://glimesh-user-assets.nyc3.cdn.digitaloceanspaces.com/uploads/avatars/FadedKamui.png?v=63794027172\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;FadedKamui\u0026#34; } } }, // and so on... Sending Messages #  The Glimesh API uses mutations to send messages. The request must contain this mutation with a channel ID and a chat message. Structure it as show below. Make sure to replace MESSAGE with your chat message and ID with your channel ID.\nmutation { createChatMessage(channelId:6, message: {message: \u0026#34;MESSAGE\u0026#34;}) { message, insertedAt, user { username } } }  This should go in the body of the request.\n Glimesh will return with the message that was sent to chat. If you want more data you have to request it. The chatMessage reference can be found here.\n{ \u0026#34;data\u0026#34;: { \u0026#34;createChatMessage\u0026#34;: { \u0026#34;insertedAt\u0026#34;: \u0026#34;2021-01-08T05:03:44\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;MESSAGE\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;AFaithfulServant\u0026#34; } } } } This is all of the info required to interact with the chat API. Although this is a viable method, using websockets is the standard way of connecting to the chat. Websockets provide a constant connection and eliminates the need to query the API for new information. This is essential for services such as chatbots. If you have any questions talk to us in our discord.\n"}),a.add({id:17,href:'/api-docs/docs/chat/projects/sitewidesubscription/',title:"Site Wide Subscription",section:"Projects",content:"Site Wide Chat Messages #  The Glimesh API allows you to subscribe to any channel to listen for chat messages. There is no limit to the amount of channels that you can listen to. In this project we will listen for every chat message from every user across the entire site. Before starting you should fully understand the WebSocket Tutorial.\nFirst we need to open a websocket connection to Glimesh. Use the process from the websocket tutorial linked above to get the connection open. Instead of subscribing to a specific channel you want to subscribe to the chatMessage event. You can do so with this:\n[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;doc\u0026#34;,{\u0026#34;query\u0026#34;:\u0026#34;subscription{ chatMessage { user { username avatarUrl } message } }\u0026#34;}] Normally the event requires a channel ID as a parameter. Since we don\u0026rsquo;t specify which channel to listen to it connects to every channel on the site. All you have to do is log the messages as they come in!\n[null,null,\u0026#34;__absinthe__:doc:-576460752298178591:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;,\u0026#34;subscription:data\u0026#34;,{\u0026#34;result\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;chatMessage\u0026#34;:{\u0026#34;message\u0026#34;:\u0026#34;hello world!\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;avatar\u0026#34;:\u0026#34;/uploads/avatars/Mytho.png?v=63762672056\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;Mytho\u0026#34;}}}},\u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752298178591:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;}] In the example above we requested the message as well as the username and avatar of the chatter. This query shows all of the possible data we can get from a chat message.\nsubscription { chatMessage { id, insertedAt, message, updatedAt, channel { # Channel data }, user { # User data }, tokens { text, type, ...on EmoteToken { src, text, type, }, ...on TextToken { text, type }, ...on UrlToken { text, type, url } } } } This is all of the info required to listen to every chatroom. If you have any questions talk to us on our Discord.\n"}),a.add({id:18,href:'/api-docs/docs/chat/websockets/',title:"Websockets",section:"Chat",content:"Chat WebSockets #  Glimesh uses WebSockets to allow for constant communication between you and the chat API. To connect to a chat you will need an access token or a client ID. Keep in mind that using a client ID will keep you in read-only mode for chat environments. The access token must have the chat scope to post messages.\n If you are testing you can use client credentials to get an access token. This will allow you to talk as your own account without going through the entire auth process.\n Preparing the Connection #  First, build your URL that you will connect to. It should look like this:\nwss://glimesh.tv/api/socket/websocket?vsn=2.0.0\u0026amp;token=TOKEN_HERE That URL is for access token authentication. If you are using a client ID use this instead:\nwss://glimesh.tv/api/socket/websocket?vsn=2.0.0\u0026amp;client_id=CLIENT_ID  Make sure to replace TOKEN_HERE or CLIENT_ID with the proper token or ID.\n Start by opening a secure websocket connection to the URL you are using. When the connection is opened we send Glimesh a join request in JSON format to stay connected to the socket. The array below is a example of what this should look like.\n[\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;__absinthe__:control\u0026quot;,\u0026quot;phx_join\u0026quot;,{}] Notice that this is a JSON array. Some WebSocket libraries only allow you to send strings or specially formatted JSON. Sometimes you need to encase the data in a string. If the connection closes immediately you may need to change the type of your request. This depends purely on your library, if you are having trouble talk to us in our discord.\n Javascript example using the ws NPM package:\nconnection.send(\u0026#39;[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_join\u0026#34;,{}]\u0026#39;); // Option 1 connection.send(JSON.stringify([\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_join\u0026#34;,{}])); //Preferred option  The first value is the join ref. The second is the normal ref. They can be useful for multi-connections but we will use the value of 1 for all refs in this doc. The third is the topic. The fourth is the event. The fifth is for a payload. Glimesh does not require a payload for this request so we can leave this blank {} .\nIf Glimesh successfully receives our request we will get a response similar to what we sent. Notice that the first two values are the same. The response tells us that Glimesh is ready.\n[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] Joining Chat #  Now that Glimesh has accepted our connection we can connect to a chat. You will need a channel ID for the channel you want to connect to. If you do not know the channel ID you can query the API for it. Simply replace Mytho with the proper user.\nquery { channel(username: \u0026#34;Mytho\u0026#34;) { id } }  Remember: Channel IDs and user IDs are different things. Everyone is a user but not everyone has a channel.\n Once you have the ID we can join the chat. Send this through the connection:\n[\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;__absinthe__:control\u0026quot;,\u0026quot;doc\u0026quot;,{\u0026quot;query\u0026quot;:\u0026quot;subscription{ chatMessage(channelId: 6) { user { username avatar } message } }\u0026quot;,\u0026quot;variables\u0026quot;:{} }] Make sure to replace 6 with your channel ID! The query we just sent will determine what data is sent to us every time a chat message appears in chat. In this example we requested the message and the user who sent it. We ask for the username and avatar of the user in the user object.\n To view a list of everything you can request check out voyager here\n Glimesh will send us a response:\n[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{\u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752303349214:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] Staying Connected (heartbeat) #  Now we are connected to chat! The only thing left to do is send a heartbeat to Glimesh so the connection won\u0026rsquo;t be closed. You need to send a heartbeat every 20 seconds. Structure it as follows:\n[\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;phoenix\u0026quot;,\u0026quot;heartbeat\u0026quot;,{}] Glimesh will respond with:\n[\u0026#34;null\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;phoenix\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] Now Glimesh won\u0026rsquo;t disconnect us and we have a stable chat connection! Next we will parse incoming messages and send messages back to chat.\nIncoming Messages #  First let\u0026rsquo;s handle incoming messages. A chat message sent from the API would look like this:\n[null,null,\u0026#34;__absinthe__:doc:-576460752298178591:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;,\u0026#34;subscription:data\u0026#34;,{\u0026#34;result\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;chatMessage\u0026#34;:{\u0026#34;message\u0026#34;:\u0026#34;hello world!\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;avatar\u0026#34;:\u0026#34;/uploads/avatars/Mytho.png?v=63762672056\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;Mytho\u0026#34;}}}},\u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752298178591:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;}] It is returning the data that we requested when we connected to this channel. The subscription ID helps you keep track of which channel the message is from. When you receive a message you need to parse the JSON data. Then you can get any of the data from the response.\n The chat API is being worked on so the structure will likely change in a future update.\n Sending Messages #  Next we will send a message back to chat. We must use a mutation to do so. Send this to chat:\n[\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;__absinthe__:control\u0026quot;,\u0026quot;doc\u0026quot;,{\u0026quot;query\u0026quot;:\u0026quot;mutation {createChatMessage(channelId:6, message: {message: \\\u0026quot;Hello There!\\\u0026quot;}) {message }}\u0026quot;,\u0026quot;variables\u0026quot;:{}}]  Don\u0026rsquo;t forget to replace 6 with your channel ID and Hello World with your message! The \\ before the quotes are used to prevent the JSON structure from breaking. Depending on how your lib handles ws messages they may not be necessary. The format for sending messages is very strict, ensure Glimesh receives your data as valid JSON.\n Only access tokens with the chat scope can talk in chat. Client IDs are read only. In the above data we requested to have the message returned to us when Glimesh sent it to chat. Glimesh will confirm that the message was received:\n[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;createChatMessage\u0026#34;:{\u0026#34;message\u0026#34;:\u0026#34;Hello There!\u0026#34;}}},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] WebSocket API Queries #  You don\u0026rsquo;t need to disconnect from the connection to make a normal API request. You can send requests from within your websocket connection! As with normal queries you are limited by the scope of your access token or client ID. Let\u0026rsquo;s build a simple request.\nquery { followers(streamerUsername: \u0026#34;CHANNEL\u0026#34;) { id, user { username } } } In this example we request the ID and username of the followers of a channel. Replace CHANNEL with any streamer on Glimesh. Keep in mind that they must be a channel and not just a normal user. Add this query as the payload in the message that we will send to the API. As with all requests we must make this valid JSON before sending it to Glimesh.\n[\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;__absinthe__:control\u0026quot;,\u0026quot;doc\u0026quot;,{\u0026quot;query\u0026quot;:\u0026quot;query {followers(streamerUsername: \\\u0026quot;CHANNEL\\\u0026quot;) {id,user {username}}}\u0026quot;}]  This snippet is already JSON, you may have to make adjustments depending on your websocket library.\n Glimesh will respond:\n[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;followers\u0026#34;:[{\u0026#34;id\u0026#34;:\u0026#34;613\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;username\u0026#34;:\u0026#34;Mytho\u0026#34;}},{\u0026#34;id\u0026#34;:\u0026#34;629\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;username\u0026#34;:\u0026#34;TheCat\u0026#34;}},{\u0026#34;id\u0026#34;:\u0026#34;752\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;username\u0026#34;:\u0026#34;Kirby\u0026#34;}},{\u0026#34;id\u0026#34;:\u0026#34;11992\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;username\u0026#34;:\u0026#34;RainbowFist\u0026#34;}}]}},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] This is all the info you will need to connect and use the chat API. If you have any questions talk to us in our discord!\nConnection Issues #  The most common issue is the connection closing with no message as to why. One of two things has happened:\n Heartbeat: You must send a heartbeat message to Glimesh every 30 seconds or Glimesh will drop the connection. Format: The chat API must receive data in the proper format. Most requests will need to be sent in a JSON array. The refs must be surrounded by quotes. The message in the mutation must also contain quotes. You may have to use a backslash to properly format the chat message. \\\u0026quot;message data\\\u0026quot;  "}),a.add({id:19,href:'/api-docs/docs/developerresources/libraries/',title:"Libraries",section:"Developer Resources",content:"Community Libraries #  This is a list of community created libraries to help communicate with the API. All of these libraries are community made and not official in any way.\nNodeJS/TypeScript #  https://www.npmjs.com/package/glimesh-chat\nA library for connecting to chat and using moderator actions such as timeouts and bans.\nAn access token is required to use this module.\nCreated by Innectic\nC# #  https://www.nuget.org/packages/StreamingClientLibrary.Glimesh/\nA library for connecting to the Glimesh chat API in C#.\nThis library has other functions for subscriptions and queries.\nCreated by SaviorXTanren\n"}),a.add({id:20,href:'/api-docs/docs/reference/api/',title:"API",section:"Reference",content:"API Requests #  This document shows common API requests that may be of use. To see the most recent version of the API visit https://glimesh.tv/api in the docs section.\nRemove any comments before sending to Glimesh.\nCategory List #  Returns a list of all the categories. Query query { categories { id, # ID of the category name, # Name of the category slug, # Slug of the category (lowercase name) tagName, # The parent and current category: Art \u0026gt; Digital parent { # The parent category. Null if no parent exists. name # all of the above fields are available } } } Response This shows two of the categories returned.\n{ \u0026#34;data\u0026#34;: { \u0026#34;categories\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Gaming\u0026#34;, \u0026#34;parent\u0026#34;: null, \u0026#34;slug\u0026#34;: \u0026#34;gaming\u0026#34;, \u0026#34;tagName\u0026#34;: \u0026#34;Gaming\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;13\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Digital\u0026#34;, \u0026#34;parent\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Art\u0026#34; }, \u0026#34;slug\u0026#34;: \u0026#34;digital\u0026#34;, \u0026#34;tagName\u0026#34;: \u0026#34;Art \u0026gt; Digital\u0026#34; }, ] } }  "}),a.add({id:21,href:'/api-docs/docs/reference/apireference/',title:"API Reference",section:"Reference",content:"Remove any comments before sending to Glimesh.\nCategory List #  Returns a list of all the categories. Query query { categories { id, # ID of the category name, # Name of the category slug, # Slug of the category (lowercase name) tagName, # The parent and current category: Art \u0026gt; Digital parent { # The parent category. Null if no parent exists. name # all of the above fields are available } } } Response This shows two of the categories returned.\n{ \u0026#34;data\u0026#34;: { \u0026#34;categories\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Gaming\u0026#34;, \u0026#34;parent\u0026#34;: null, \u0026#34;slug\u0026#34;: \u0026#34;gaming\u0026#34;, \u0026#34;tagName\u0026#34;: \u0026#34;Gaming\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;13\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Digital\u0026#34;, \u0026#34;parent\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Art\u0026#34; }, \u0026#34;slug\u0026#34;: \u0026#34;digital\u0026#34;, \u0026#34;tagName\u0026#34;: \u0026#34;Art \u0026gt; Digital\u0026#34; }, ] } }  "}),a.add({id:22,href:'/api-docs/docs/reference/channel/',title:"Channel",section:"Reference",content:"Channel Subscription #  Shows all the properties of the channel object. Note that for nested objects only one propery is shown.\nsubscription { channel(id: 6) { bans(last: 3) { edges { node { reason } } } blockLinks category { name } chatBgUrl chatRulesHtml chatMessages(last: 3) { edges { node { message } } } chatRulesMd disableHyperlinks hmacKey id inaccessible insertedAt language matureContent minimumAccountAge moderationLogs { edges { node { action } } } moderators { edges { node { canBan } } } posterUrl requireConfirmedEmail showOnHomepage showRecentChatMessagesOnly status stream { id } streamKey streamer { username } streams { edges { node { countViewers } } } subcategory { name } tags { name } title updatedAt } }  A full list of every property can be found in a GraphQL editor. An interactive version of the API can be found on our voyager page.\n"}),a.add({id:23,href:'/api-docs/docs/reference/channelreference/',title:"Channel Reference",section:"Reference",content:"Shows all the properties of the channel object. Note that for nested objects only one propery is shown.\nsubscription { channel(id: 6) { bans(last: 3) { edges { node { reason } } } blockLinks category { name } chatBgUrl chatRulesHtml chatMessages(last: 3) { edges { node { message } } } chatRulesMd disableHyperlinks hmacKey id inaccessible insertedAt language matureContent minimumAccountAge moderationLogs { edges { node { action } } } moderators { edges { node { canBan } } } posterUrl requireConfirmedEmail showOnHomepage showRecentChatMessagesOnly status stream { id } streamKey streamer { username } streams { edges { node { countViewers } } } subcategory { name } tags { name } title updatedAt } } "}),a.add({id:24,href:'/api-docs/docs/reference/chat/',title:"Chat",section:"Reference",content:"Chat #  Shows all of the fields in the chatMessage object.\nchatMessage { id, insertedAt, message, updatedAt, channel { // Channel data  }, user { // User data  } } "}),a.add({id:25,href:'/api-docs/docs/reference/chatparts/',title:"Chat Parts",section:"Reference",content:"Chat Parts #  All the possbile data to query from a chat part.\nsubscription{ chatMessage(channelId:6) { message, user { id }, tokens { text, type, ...on EmoteToken { src, text, type, }, ...on TextToken { text, type }, ...on UrlToken { text, type, url } } } } A possible response. (Dependent on query and message)\n[ null, null, \u0026#34;__absinthe__:doc:-576460752302054414:1C57C19163D4D59F61626243BCCA79AB4E50D5C4C2BD8BDA0DDCE83517B20C16\u0026#34;, \u0026#34;subscription:data\u0026#34;, { \u0026#34;result\u0026#34;:{ \u0026#34;data\u0026#34;:{ \u0026#34;chatMessage\u0026#34;:{ \u0026#34;tokens\u0026#34;:[ { \u0026#34;text\u0026#34;:\u0026#34;Hello Glimesh Devs \u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;/emotes/svg/glimsmile.svg\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;:glimsmile:\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;emote\u0026#34;, }, { \u0026#34;text\u0026#34;: \u0026#34;http://glimesh.tv\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;url\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://glimesh.tv\u0026#34; }, ] } } }, \u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752302054414:1C57C19163D4D59F61626243BCCA79AB4E50D5C4C2BD8BDA0DDCE83517B20C16\u0026#34; } ]  "}),a.add({id:26,href:'/api-docs/docs/reference/chatpartsreference/',title:"Chat Parts Reference",section:"Reference",content:"All the possbile data to query from a chat part.\nsubscription{ chatMessage(channelId:6) { message, user { id }, tokens { text, type, ...on EmoteToken { src, text, type, }, ...on TextToken { text, type }, ...on UrlToken { text, type, url } } } } A possible response. (Dependent on query and message)\n[ null, null, \u0026#34;__absinthe__:doc:-576460752302054414:1C57C19163D4D59F61626243BCCA79AB4E50D5C4C2BD8BDA0DDCE83517B20C16\u0026#34;, \u0026#34;subscription:data\u0026#34;, { \u0026#34;result\u0026#34;:{ \u0026#34;data\u0026#34;:{ \u0026#34;chatMessage\u0026#34;:{ \u0026#34;tokens\u0026#34;:[ { \u0026#34;text\u0026#34;:\u0026#34;Hello Glimesh Devs \u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;/emotes/svg/glimsmile.svg\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;:glimsmile:\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;emote\u0026#34;, }, { \u0026#34;text\u0026#34;: \u0026#34;http://glimesh.tv\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;url\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://glimesh.tv\u0026#34; }, ] } } }, \u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752302054414:1C57C19163D4D59F61626243BCCA79AB4E50D5C4C2BD8BDA0DDCE83517B20C16\u0026#34; } ] "}),a.add({id:27,href:'/api-docs/docs/reference/chatreference/',title:"Chat Reference",section:"Reference",content:"Shows all of the fields in the chatMessage object.\nchatMessage { id, insertedAt, message, updatedAt, channel { // Channel data  }, user { // User data  } } "}),a.add({id:28,href:'/api-docs/docs/reference/mod/',title:"Mod",section:"Reference",content:"Mod Reference #  Shows all the queries related to moderation. Note that for nested properties only one property is shown.\nShort and long timeouts have the same properties.\nmutation { shortTimeoutUser(channelId:6, userId:201) { action, channel {id}, insertedAt, moderator {displayname}, updatedAt, user {displayname} } } Banning and unbanning a user have the same properties.\nmutation { banUser(channelId:6, userId:201) { action, channel {id}, insertedAt, moderator {displayname}, updatedAt, user {displayname} } } Deletes a message.\nmutation { deleteChatMessage(channelId:6, messageId: 999) { action, channel {id}, insertedAt, moderator { displayname }, updatedAt, user { displayname } } } Shows all of the properties for a moderation log.\nquery { channel(id: 6) { moderationLogs { edges { node { action channel { id } insertedAt moderator { username } updatedAt user { username } } } } } }  A full list of every property can be found in a GraphQL editor. An interactive version of the API can be found on our voyager page.\n"}),a.add({id:29,href:'/api-docs/docs/reference/modreference/',title:"Mod Reference",section:"Reference",content:"Shows all the queries related to moderation. Note that for nested properties only one property is shown.\nShort and long timeouts have the same properties.\nmutation { shortTimeoutUser(channelId:6, userId:201) { action, channel {id}, insertedAt, moderator {displayname}, updatedAt, user {displayname} } } Banning and unbanning a user have the same properties.\nmutation { banUser(channelId:6, userId:201) { action, channel {id}, insertedAt, moderator {displayname}, updatedAt, user {displayname} } } Deletes a message.\nmutation { deleteChatMessage(channelId:6, messageId: 999) { action, channel {id}, insertedAt, moderator { displayname }, updatedAt, user { displayname } } } Shows all of the properties for a moderation log.\nquery { channel(id: 6) { moderationLogs { edges { node { action channel { id } insertedAt moderator { username } updatedAt user { username } } } } } } "}),a.add({id:30,href:'/api-docs/docs/reference/scopes/',title:"Scopes",section:"Reference",content:"Scopes #  Scopes are permissions that a developer application requests from a client. The client must approve all of the scopes that you request. You should only request scopes that you plan to use. Below documents all of the available scopes.\n public: Get public information about the user and other users on Glimesh. email: View the email of the user. chat: View and speak in a chatroom. stream View the streamkey of the user.  Note that more scopes will be added over time\n"}),a.add({id:31,href:'/api-docs/docs/reference/scopesreference/',title:"Scopes Reference",section:"Reference",content:" public: Get public information about the user and other users on Glimesh. email: View the email of the user. chat: View and speak in a chatroom. stream View the streamkey of the user.  "})})()