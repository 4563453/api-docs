'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/api-docs/docs/contributing/',title:"Contributing",section:"Docs",content:"Contributing #  Thanks for wanting to contribute to the api-docs! We are grateful for your help.\nContributing to the API Docs. #  Anyone can contribute to the docs. We only ask that you follow a few guidelines when contributing.\n  Follow the file structure. Each topic (or sub-topic) has language specific folders and a basic guide. Inside each language folder there should be a tutorial and a code file if applicable. You do not need to tackle an entire topic by yourself. Completing even one tutorial is helpful!\n  Follow the tutorial structure. Try to keep each tutorial as objective as possible. You can have some personal expression but try to keep it limited. We want these guides to be as short and as simple as they can get. The tutorial should be written in Markdown. Explain every step and clearly document any code used. Don\u0026rsquo;t do this.\n  Run any code through a prettier software. Try to keep the code looking nice! It doesn\u0026rsquo;t matter which formatter you use but we want the code to be readable.\n  Follow the Glimesh and Github TOS (Terms of Service). Any tutorial that violates either of the TOS will be removed. Any malicious code will be removed.\n  Process #  Start by forking the repository. Access the fork on your PC or on https://github.com/YOURNAME/api-docs . You will want an environment capable of editing markdown (.md) files. Any IDE will do.\n Stack Edit is a free markdown editor running in the browser. It is easy to use and has many tools for markdown formatting. You can copy the contents of the files there to edit them.\n You will need to create your tutorial as described above. You will also need Hugo installed. Get the extended features edition.\n This installation can be a bit complex for Windows users so you may want to follow a tutorial.\n In the command line navigate to the folder containing your fork. Run hugo server --minify --theme book in your terminal. If you get a theme error you can run git clone https://github.com/alex-shpak/hugo-book themes/book or install the git submodules. It will install the necessary theme files. When it finishes installing run the server command again. This will open a server on http://localhost:1313/api-docs.\n The server will restart when any changes are saved. Editing config or other important files will require a manual restart though.\n You can add special markdown formatting if you want to. If you are making a new file Hugo will detect the it and update the menu on the left side of the page with your new file. The menu will alter itself to match the file directory. This may require a restart of the server for the menu to update.\n Notice that every folder with content has a _index.md file. Create a new _index.md file and fill it with the info below if you created a new folder. This allows the tutorial to be collapsible in the menu. If the weight is the same they will be alphabetically sorted.\n --- bookCollapseSection: true weight: 20 --- When you are satisfied with the look of your tutorial you can submit a PR. Close the server. Commit and push your changes. Create a pull request with a brief overview of your tutorial/topic. We may ask you to make changes. Once accepted we will add your tutorial to the repo and add it to the website.\nThank you for contributing!\n"}),a.add({id:1,href:'/api-docs/docs/dev-app/',title:"Dev App",section:"Docs",content:"Developer Application #  Although making an application is easy, developers new to OAuth may find some of it confusing. This tutorial will explain the basics of what information is asked for and what is it used for.\n Ready to make your application? Start here\n Name #  The name of your project is a user friendly name for your application. Both Glimesh and your users will see this when they authenticate with your app.\nHomepage #  The homepage of your app is where your product (if applicable) is located. This could be a website for a chatbot, an online tool, or anything that uses the Glimesh API. You do not need to have a public domain to show your product if you don\u0026rsquo;t want to. Using a localhost URL is fine.\nDescription #  The description is a basic explanation of your app. This should be a brief overview of what your app will be used for. Details, details, details!\nImage #  The image you choose here is shown to all users who authenticate with your app. It should be representative of your app and must not violate the Glimesh Terms of Service.\nAllowed Redirect URIs #  The redirect URIs are where Glimesh will redirect users of your app after they authenticate with your app. You specify which one to redirect to in the client request. You should have one URL per line. We prefer HTTPS over HTTP but using a locally hosted HTTP server will be fine.\nA complete dev app will look like this when authenticating.\n"}),a.add({id:2,href:'/api-docs/docs/authentication/accesstoken/clientcredentials/',title:"Client Credentials",section:"Access Token",content:"Client Credentials (Access Token) #  An access token can be used to query the Glimesh API on behalf of a user. Normally you have to get a token from a user. Client credentials allows us to generate an access token for our own account to act as an authenticated user. This is frequently used for testing purposes.\nRequesting A Token #  Before requesting a token you must have a developer application. You will need your client ID and secret key. Simply make a POST request to the following URL replacing CLIENT_ID and SECRET_KEY with the info from your dev app.\nhttps://glimesh.tv/api/oauth/token?grant_type=client_credentials\u0026amp;client_id=CLIENT_ID\u0026amp;client_secret=SECRET_KEY Glimesh will respond with:\n{ \u0026#34;access_token\u0026#34;: \u0026#34;qwertyuiop1234567890\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2021-03-21T19:32:21\u0026#34;, \u0026#34;expires_in\u0026#34;: 21600, \u0026#34;refresh_token\u0026#34;: null, \u0026#34;scope\u0026#34;: \u0026#34;public\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34; } The access token received will allow us to make requests as if we were using a normal access token. We have permissions for all the scopes and have access to any user specific properties. The token generated will expire in 6 hours just like a normal token. Unlike normal tokens, this cannot be refreshed. As with all auth information you must keep this private.\nIf you have any questions talk to us in the #dev channel in our Discord.\n"}),a.add({id:3,href:'/api-docs/docs/api/graphiql/',title:"Graphiql",section:"API",content:"GraphiQl (/API) #  Glimesh has a built in webpage that we can use to test the API without a dev environment. For a graphic version see Voyager.\nGetting Started #  Click on our API page to begin. You will need to be logged in to Glimesh for this to work. When it is done loading you will see the page below.\nNavigation #  The top part of the Explorer shows what queries you have saved. These are stored in the browser and will persist across restarts. If this is your first time viewing the Explorer you will only have 1 query shown.\nBelow that shows the connection URLs for Glimesh. The URL is correct, however the WS URL is not. More on that below. Glimesh handles your authentication for queries/mutations in the session so you don\u0026rsquo;t need to add any headers to requests.\nOn the right you have the GraphiQL import/export buttons. You can move saved queries to other devices. You also have the option to reset the workspace and bring back previous queries.\nThe bottom left box is for structuring your queries/subscriptions. A basic query is shown below. The box has intellisense, press CTRL+Spacebar to view autocompletion possibilities. Below the query box is the variable section (You probably have to drag it up first!). Here you can add GraphQL variables for use in your queries.\nThe Explorer also has built in documentation. You can view it by clicking on the docs link on the right. These docs go over the basic queries/subs/mutations and show what data they return.\n The Explorer docs show all of the query specific info. This is useful if you are looking for something specific. The docs on this website are useful if you are looking for non API info (such as OAuth) or if you want to see some examples.\n Queries/Mutations #  Queries/mutations function as expected. The data you request or modify will be shown on the right. Note that this is still scope protected, so you can only request data that you have access to.\nSubscriptions #  Subscriptions require modification to work in the Explorer. You need to change the WS URL to include a client ID. If you do not yet have a dev app you should create one here.\nChange the WS URL to the below URL.\nwss://glimesh.tv/api/socket?client_id=YOUR_ID_HERE Now you can subscribe to any topic on Glimesh! If you have any questions let us know in our discord!\n"}),a.add({id:4,href:'/api-docs/docs/api/live-updates/channels/',title:"Channels",section:"Live Updates",content:"Channel Changes #  Using graphQL subscriptions we can listen for changes to a channel without making repeated queries! Before starting this tutorial you should understand basic graphQL and have a method of authentication. Completing our websocket tutorial will also be helpful.\n Need authentication? Start with access tokens\n  Websocket tutorial can be found here\n Selecting a Channel #  Before we can subscribe to a user we need a channel ID. This will specify which channel we are wanting to connect to. The easiest way to get a channel ID is to go to glimesh.tv/api and make the following query. Simply replace YOURNAME with the channel you want to listen to.\nquery { channel(username: \u0026#34;YOURNAME\u0026#34;) { id } } Glimesh will return a response that should look something like this.\n{ \u0026#34;data\u0026#34;: { \u0026#34;channel\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34; } } } Building Our Subscription #  Now that we have a channel ID we can build our subscription query. Glimesh will send us data through this subscription whenever a change is made to the selected channel. Our query needs to specify the information we want returned when this happens.\n Note that any change to the channel will result in data being sent even if you did not listen for that specific change. The data received will contain the query and nothing more.\n To keep things simple we will listen for a change in the channel title.\nsubscription { channel(id:6) { title } }  Don\u0026rsquo;t forget to replace 6 with your channel ID!\n If Glimesh detects a change in the channel it will send us the data that we asked for. As noted above any change will cause this data to be sent, not just a title change. Next we will create a connection to Glimesh and send them our subscription!\nWebsocket Connection #  Since this is a subscription a websocket connection is needed. If you have followed the chat websocket tutorial you can modify that code to fit this tutorial. If you have not done so you must do the following -\n  Create a connection URL:\n  For Access Tokens: wss://glimesh.tv/api/socket/websocket?vsn=2.0.0\u0026amp;token=TOKEN_HERE\n  For Client IDs: wss://glimesh.tv/api/socket/websocket?vsn=2.0.0\u0026amp;client_id=CLIENT_ID\n   Make sure to replace TOKEN_HERE or CLIENT_ID with their proper values!\n   Open a connection and send this through:\n  [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;__absinthe__:control\u0026quot;,\u0026quot;phx_join\u0026quot;,{}] Send this through replacing 6 with your channel ID.  [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;__absinthe__:control\u0026quot;,\u0026quot;doc\u0026quot;,{\u0026quot;query\u0026quot;:\u0026quot;subscription{ channel(ID: 6) { title, id } }\u0026quot;,\u0026quot;variables\u0026quot;:{} }] Send this through every 30 seconds.  [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;phoenix\u0026quot;,\u0026quot;heartbeat\u0026quot;,{}]  Having issues? The websocket tutorial goes into more detail about the connection. You may find it helpful to complete that tutorial first. If you are still having problems talk to us in discord.\n The above code will connect to Glimesh, subscribe to any changes, and keep us from getting disconnected. To test our code we need to make a change on the channel that we specified. We requested to be sent the current title. Lets change it and see our code in action!\nBefore (Basic Query)\n{ \u0026#34;data\u0026#34;: { \u0026#34;channel\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Hello Glimesh API \u0026#34; } } } After (Websocket)\n[ null, null, \u0026#39;__absinthe__:doc:-576460752299317854:BEF9A4EF11FCFAD0A1B750BCEE8C2CBEAB66ADDAFE214A6CF692FBA68473F68A\u0026#39;, \u0026#39;subscription:data\u0026#39;, { result: { channel: { id: \u0026#39;6\u0026#39;, title: \u0026#39;Hello Glimesh API \u0026#39; } }, subscriptionId: \u0026#39;__absinthe__:doc:-576460752299317854:BEF9A4EF11FCFAD0A1B750BCEE8C2CBEAB66ADDAFE214A6CF692FBA68473F68A\u0026#39; } ] After the title was changed Glimesh sent us the new title. All properties will function the same way. Using this format you can listen to any property of any channel on Glimesh!\n Looking for a reference? Click here to view all the channel properties.\n If you have any questions talk to us in the #dev channel in our Discord.\n"}),a.add({id:5,href:'/api-docs/docs/api/live-updates/followers/',title:"Followers",section:"Live Updates",content:"Follower Alerts #  This is a tutorial for follow alerts. This guide assumes you have a client ID or an access token from a user. You should also have a websocket connection open from this tutorial. Having basic GraphQL knowledge would also be helpful.\n New to GraphQL? This tutorial explains the basics. https://graphql.org/learn/schema/\n Building the Subscription #  Follow alerts are made of a standard subscription. The streamer ID of the channel that you want to have alerts for is required. A streamer ID is equal to the user ID. You can acquire the ID with the below query.\nquery { user(username:\u0026#34;Mytho\u0026#34;) { id } }  Make sure to replace Mytho with the channel name.\n We will insert this ID into the below subscription. You must subscribe to this event through a websocket connection. Glimesh will notify us whenever a user follows the channel.\nsubscription { followers(streamerId:6) { hasLiveNotifications, id, insertedAt, streamer { username }, updatedAt, user { username } } } The above subscription shows all of the properties we can receive. This excludes nested properties. This information will be sent to us whenever the specified channel gets a new follower.\n Need a tutorial for connecting to the API with websockets? Click here\n Follower Query #  A subscription is the standard way to get follower alerts. However, this is not the only method to get the followers of a channel. We can make a query to get the followers of a channel as well as the followers of a user. You will need name of the streamer or of the user. The following query will return the followers of a streamer.\nquery { followers(streamerUsername:\u0026#34;Mytho\u0026#34;) { hasLiveNotifications, id, insertedAt, streamer { username }, updatedAt, user { username } } } We requested the same properties as before. Glimesh will send us a JSON format response.\n{ \u0026#34;data\u0026#34;: { \u0026#34;followers\u0026#34;: [ { \u0026#34;hasLiveNotifications\u0026#34;: false, \u0026#34;id\u0026#34;: \u0026#34;16946\u0026#34;, \u0026#34;insertedAt\u0026#34;: \u0026#34;2021-02-06T01:04:42\u0026#34;, \u0026#34;streamer\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; }, \u0026#34;updatedAt\u0026#34;: \u0026#34;2021-02-06T01:04:42\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Heiwa\u0026#34; } }, { \u0026#34;hasLiveNotifications\u0026#34;: false, \u0026#34;id\u0026#34;: \u0026#34;629\u0026#34;, \u0026#34;insertedAt\u0026#34;: \u0026#34;2020-08-09T16:35:55\u0026#34;, \u0026#34;streamer\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; }, \u0026#34;updatedAt\u0026#34;: \u0026#34;2020-08-09T16:35:55\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;TheCat\u0026#34; } }, and so on... We can also request who a user is following. The query is nearly identical. The only thing we change is the parameter. Replace streamerUsername with userUsername.\nquery { followers(userUsername:\u0026#34;Mytho\u0026#34;) { hasLiveNotifications, id, insertedAt, streamer { username }, updatedAt, user { username } } } Stuck with something? Talk to us in Discord. We would be happy to help you!\n"}),a.add({id:6,href:'/api-docs/docs/api/query-api/basic-query/',title:"Basic Query",section:"Query API",content:"Glimesh API Requests #  This is a basic tutorial for communicating with the Glimesh API. This guide assumes you have a client ID or an access token from a user. Having basic GraphQL knowledge would also be helpful.\n New to GraphQL? This tutorial explains the basics. https://graphql.org/learn/schema/\n Authentication #  All requests made to Glimesh must contain the proper authentication. The authentication value should be included as a header of the request. This value will change depending on the authentication type. For access tokens use:\nAuthorization: Bearer YOUR_TOKEN\nReplace YOUR_TOKEN with your access token. If you are using a client ID to authenticate you must use this instead:\nAuthorization: Client-ID YOUR_CLIENT_ID\nReplace YOUR_CLIENT_ID with your ID. This will allow you access to the API.\n A client ID can use the API in read only mode. An access token is limited by its scopes.\n Building Our Request #  The Glimesh API uses GraphQL. You must structure your query accordingly. The API has documentation here. It will allow you to view all of the possible queries. Some data requires an access token with a special scope. For this example we will structure a basic request that requires no special scope. The query must be included in the body of the request.\nquery { user (username: \u0026#34;USERNAME\u0026#34;){ username, id} } Make sure to change \u0026ldquo;USERNAME\u0026rdquo; to a user on Glimesh. We are requesting the username and ID of the user. Now that we have our authentication and our query we can request the data. Send a POST request with our query and header from above to:\nhttps://glimesh.tv/api\nGlimesh will send a JSON formatted response when it receives our request.\n{ \u0026#34;data\u0026#34;: { \u0026#34;user\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;154\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } } } You can parse the response to get the data you want. You could test every query like this but there is an easier way.\nGlimesh.tv/api #  Glimesh has a website that we can visit to make queries. This is a basic GUI that lets us view the API and has intellisense built in. It is very useful for testing queries.\n You must be logged in to Glimesh for this site to work. You make queries as the authenticated user.\n Visit the website here. You can make any query that you want.\nIn this example we request a list of categories on Glimesh. We specify that we want the name of each. Glimesh will return the data on the right.\nFrom this website you can read the API spec and query for any data that you want. If you have any questions feel free to talk to us in Discord.\nCommon Errors #  There are a few errors you may encounter while querying the API.\nError: 401 Unauthorized. You must be logged in to access the API.\nThis is an authentication issue. Check your authentication header. You need to use the right type of authentication and make sure that the information is valid.\n  Internal Server Error  This is usually user error rather than a server error. Ensure the auth info is correct and check your query for errors. If you think your query is correct try it here.\n  syntax error before: \\\u0026quot;\\\\\\\u0026quot;QUERY\\\\\\\u0026quot;\\\u0026quot;\u0026quot;  Your query is in the incorrect format. It must match the GraphQL specifications. You can only request properties that exist and you must have the proper permissions to access them. Check the API docs for more information.\n Stuck with something? Talk to us in Discord. We would be happy to help you!\n "}),a.add({id:7,href:'/api-docs/docs/api/query-api/nodejs/node-query/',title:"Node Query",section:"Query API",content:"Glimesh API Requests With NodeJS #  This is a basic tutorial for communicating with the Glimesh API using NodeJS. This guide assumes you know basic JS and have an access token from a user. You can use a client ID if you do not yet have a token. Having basic GraphQL knowledge would also be helpful.\n Need a refresh? This tutorial explains the basics of graphql. https://graphql.org/learn/schema/\n Creating the Project #  We need to create a basic project. In your terminal type\nnpm init -y .\nThis will create a project.JSON file. This project uses the Request npm package. It helps with sending requests to the server and handling the response. In your terminal type\nnpm install request.\nThat is the only package that you will need!\nStarting Up #  In your project create a blank JS file. I will title mine \u0026ldquo;glimesh.js\u0026rdquo;. Start by importing the Request library. Paste this at the top of your file.\nvar request = require('request'); Now we need to build our query. The Glimesh API docs can be found here. It is a work in progress. In this example we will ask Glimesh for the name and ID of our user. If you are using an access token you can get this data in the myself object. query{ myself { username, id } } However, we need to convert this so JS can understand it. To do this we create a data variable. Paste this under the import statement above.\nvar data = ` query { myself { username, id} } ` If you are going to use a client ID you have to specify which user to get data for. This is because a client ID does not have a user identity. This query will return the same data as the myself object.\nvar data = ` query { user (username: \u0026#34;USERNAME\u0026#34;){ username, id} } ` Feel free to replace USERNAME with your own username! Since we are not accessing any private information we do not need any special permissions/scopes.\n Leave the quotations around \u0026quot;USERNAME\u0026quot;. Glimesh processes our query as graphQL. Even though data is a string Glimesh will convert it to graphQL when it receives our request. GraphQL requires that the user we search for be a string. Since we used `` to encase the contents of data, quotations must be used to keep your username a string.\n Define Options #  Next we set up the call to the API. We need to add our data variable from above and our authentication as a header. We do this with the options variable. If you do not already have an authentication method (Client ID or Access Token) you need to get one now. Paste this below your query.\nvar options = { method: \u0026#39;POST\u0026#39;, body: data, url: \u0026#39;https://glimesh.tv/api\u0026#39;, headers: { \u0026#39;Authorization\u0026#39;: \u0026#39;Bearer Your_Token\u0026#39; } }; Notice we are sending the data variable from before. If you are using an access token replace \u0026ldquo;Your_Token\u0026rdquo; with your access token in the Authorization string. It should look like this. 'Authorization': 'Bearer qertyuiop123456789'\nIf you are using a client ID replace \u0026ldquo;Bearer\u0026rdquo; with \u0026ldquo;Client-ID\u0026rdquo; and \u0026ldquo;Your_Token\u0026rdquo; with your client ID. It should look like this.\n'Authorization': 'Client-ID qwertyuiop123456789'\nSend Request #  Now we set up the request. We ask Glimesh for data and we setup a callback function to handle it when it arrives. The server will normally respond in less than one second. Paste this below the options variable.\nfunction callback(error, response, body) { if (!error \u0026amp;\u0026amp; response.statusCode == 200) { //if all works as it should...  console.log(body); //The unfiltered response  var convertedResponse = JSON.parse(body); //Convert the response so we can use it  console.log(`The user is ${convertedResponse.data.myself.username}and the ID is ${convertedResponse.data.myself.id}`); } else { console.log(error) //log any errors.  console.log(body) //sometimes the body contains the error.  } } If you searched for a user instead of myself you need to change the convertedResponse output to:\nconsole.log(`The user ${convertedResponse.data.user.username}has an ID of ${convertedResponse.data.user.id}`); Finally we send the request. At the bottom of the file add this line.\nrequest(options, callback); When you are ready, save the file and type the line below in your terminal to query the API!\nnode filename.js\nMake sure to replace \u0026ldquo;filename\u0026rdquo; with the name of your file! For example -\nnode glimesh.js\nCommon Errors #   You must be logged in to access the API.   Cause: The auth string is incorrect. Make sure the token is valid. They expire after a short period and a new token is needed. You should also check the auth string. It should look like this 'Authorization': 'Bearer qertyuiop123456789' or 'Authorization': 'Client-ID qertyuiop123456789' depending on the auth method you used.\n  Internal Server Error   Cause: This is usually user error rather than a server error. Ensure the auth info is correct and check your query. The query is a string but the contents of that variable are graphQL. If you think your query is correct try it here. Don\u0026rsquo;t forget to remove the `` when testing on the API site. Note that you must be signed in to use the API website!\n  syntax error before: \\\u0026quot;\\\\\\\u0026quot;query\\\\\\\u0026quot;\\\u0026quot;\u0026quot;   Cause: Your query is in the incorrect format. Ensure it matches the example in the code above. You can only request properties that exist and you must have the proper permissions to access them. Check the API docs for more information.\n Conclusion #  This is the basis for most API requests. If you have any questions let us know in the #dev channel in our Discord.\nThe full file can be found here.\nvar request = require(\u0026#39;request\u0026#39;); //Import the library //Define the data we want from Glimesh. var data = ` query { myself { username, id} } ` // If you used a client ID the myself object will not exist. Try this: /* var data = ` query { user (username: \u0026#34;USERNAME\u0026#34;){ username, id} }` */ //Make sure to replace USERNAME with a user!  //Tell the request library where to send the request and how to add auth var options = { method: \u0026#39;POST\u0026#39;, body: data, url: \u0026#39;https://glimesh.tv/api\u0026#39;, headers: { \u0026#39;Authorization\u0026#39;: \u0026#39;Bearer Token_Here\u0026#39; //If you are using a client ID use \u0026#39;Authorization\u0026#39;: \u0026#39;Client-ID qwertyuiop123456789\u0026#39;  } }; //Callback function runs when the data is recieved. We convert it to an object on arrival. function callback(error, response, body) { if (!error \u0026amp;\u0026amp; response.statusCode == 200) { console.log(body); //The unfiltered response  var convertedResponse = JSON.parse(body); //Convert the response  console.log(`You are ${convertedResponse.data.myself.username}and your ID is ${convertedResponse.data.myself.id}`); // If you are using a client ID you will have requested the user object. Use the line below instead!  // console.log(`The user ${convertedResponse.data.user.username} has an ID of ${convertedResponse.data.user.id}`);  } else { console.log(error); //log any errors  console.log(body); } } //send the request request(options, callback); "}),a.add({id:8,href:'/api-docs/docs/api/voyager/',title:"Voyager",section:"API",content:'Voyager is an interactive GraphQL API explorer. It allows you to view all the data in our API. Click and drag to move around the explorer. Click on a field to view its properties. Scoll to adjust zoom.\nLoading...  // Render GraphQLVoyager.init(document.getElementById(\'voyager\'), { hideDocs: true, hideSettings: false, displayOptions: { sortByAlphabet: true, }, introspection: { "data": { "__schema": { "directives": [ { "args": [ { "defaultValue": null, "description": "Included when true.", "name": "if", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } } ], "description": "Directs the executor to include this field or fragment only when the `if` argument is true.", "locations": [ "FIELD", "FRAGMENT_SPREAD", "INLINE_FRAGMENT" ], "name": "include" }, { "args": [ { "defaultValue": null, "description": "Skipped when true.", "name": "if", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } } ], "description": "Directs the executor to skip this field or fragment when the `if` argument is true.", "locations": [ "FIELD", "FRAGMENT_SPREAD", "INLINE_FRAGMENT" ], "name": "skip" } ], "mutationType": { "name": "RootMutationType" }, "queryType": { "name": "RootQueryType" }, "types": [ { "description": null, "enumValues": null, "fields": [ { "args": [ { "defaultValue": null, "description": null, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "channel", "type": { "kind": "OBJECT", "name": "Channel", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "channelId", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "chatMessage", "type": { "kind": "OBJECT", "name": "ChatMessage", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "streamerId", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "followers", "type": { "kind": "OBJECT", "name": "Follower", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "RootSubscriptionType", "possibleTypes": null }, { "description": "The `Naive DateTime` scalar type represents a naive date and time without\\ntimezone. The DateTime appears in a JSON response as an ISO8601 formatted\\nstring.", "enumValues": null, "fields": null, "inputFields": null, "interfaces": null, "kind": "SCALAR", "name": "NaiveDateTime", "possibleTypes": null }, { "description": "Represents a directive", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "args", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "__InputValue", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "description", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "locations", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "ENUM", "name": "__DirectiveLocation", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "name", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": "Check `locations` field for enum value FIELD", "description": null, "isDeprecated": true, "name": "onField", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": "Check `locations` field for enum value FRAGMENT_SPREAD", "description": null, "isDeprecated": true, "name": "onFragment", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": "Check `locations` field for enum value OPERATION", "description": null, "isDeprecated": true, "name": "onOperation", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "__Directive", "possibleTypes": null }, { "description": "A linked social account for a Glimesh user.", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Platform unique identifier, usually a ID, made into a string", "isDeprecated": false, "name": "identifier", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Platform that is linked, eg: twitter", "isDeprecated": false, "name": "platform", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Username for the user on the linked platform", "isDeprecated": false, "name": "username", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "UserSocial", "possibleTypes": null }, { "description": null, "enumValues": [ { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "LIVE" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "OFFLINE" } ], "fields": null, "inputFields": null, "interfaces": null, "kind": "ENUM", "name": "ChannelStatus", "possibleTypes": null }, { "description": "The `Boolean` scalar type represents `true` or `false`.", "enumValues": null, "fields": null, "inputFields": null, "interfaces": null, "kind": "SCALAR", "name": "Boolean", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "text", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "type", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "inputFields": null, "interfaces": [ { "kind": "INTERFACE", "name": "ChatMessageToken", "ofType": null } ], "kind": "OBJECT", "name": "TextToken", "possibleTypes": null }, { "description": "Subcategories are specific games, topics, or genre\'s that exist under a Category.", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "backgroundImageUrl", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "category", "type": { "kind": "OBJECT", "name": "Category", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "Name of the subcategory", "isDeprecated": false, "name": "name", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "URL friendly name of the subcategory", "isDeprecated": false, "name": "slug", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "source", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "sourceId", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "userCreated", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "Subcategory", "possibleTypes": null }, { "description": "A channel timeout or ban", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "channel", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "Channel", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "expiresAt", "type": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "reason", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "user", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "ChannelBan", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "defaultValue", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "description", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "name", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "type", "type": { "kind": "OBJECT", "name": "__Type", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "__InputValue", "possibleTypes": null }, { "description": "A follower is a user who subscribes to notifications for a particular user\'s channel.", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "hasLiveNotifications", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "streamer", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "user", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "Follower", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "text", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "type", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "url", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "inputFields": null, "interfaces": [ { "kind": "INTERFACE", "name": "ChatMessageToken", "ofType": null } ], "kind": "OBJECT", "name": "UrlToken", "possibleTypes": null }, { "description": "A subscription is an exchange of money for support.", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "endedAt", "type": { "kind": "SCALAR", "name": "DateTime", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "isActive", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "price", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "productName", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "startedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "DateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "streamer", "type": { "kind": "OBJECT", "name": "User", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "user", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "Sub", "possibleTypes": null }, { "description": "A stream is a single live stream in, either current or historical.", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "avgChatters", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "avgViewers", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "category", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "Category", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "channel", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "Channel", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "countChatters", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "countViewers", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "endedAt", "type": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "metadata", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "StreamMetadata", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "newSubscribers", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "peakChatters", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "peakViewers", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "resubSubscribers", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "startedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "subcategory", "type": { "kind": "OBJECT", "name": "Subcategory", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "thumbnail", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "The title of the stream.", "isDeprecated": false, "name": "title", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "Stream", "possibleTypes": null }, { "description": "A user of Glimesh, can be a streamer, a viewer or both!", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "avatar", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "avatarUrl", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "confirmedAt", "type": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "countFollowers", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "countFollowing", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Exactly the same as the username, but with casing the user prefers", "isDeprecated": false, "name": "displayname", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "A list of users who are following you", "isDeprecated": false, "name": "followers", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "Follower", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "A list of users who you are following", "isDeprecated": false, "name": "following", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "Follower", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "HTML version of the user\'s profile, should be safe for rendering directly", "isDeprecated": false, "name": "profileContentHtml", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Markdown version of the user\'s profile", "isDeprecated": false, "name": "profileContentMd", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Qualified URL for the user\'s Discord server", "isDeprecated": false, "name": "socialDiscord", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Qualified URL for the user\'s Guilded server", "isDeprecated": false, "name": "socialGuilded", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Qualified URL for the user\'s Instagram account", "isDeprecated": false, "name": "socialInstagram", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": "Use the socials field instead", "description": "Qualified URL for the user\'s Twitter account", "isDeprecated": true, "name": "socialTwitter", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Qualified URL for the user\'s YouTube account", "isDeprecated": false, "name": "socialYoutube", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "A list of linked social accounts for the user", "isDeprecated": false, "name": "socials", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "UserSocial", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "Lowercase user identifier", "isDeprecated": false, "name": "username", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "YouTube Intro URL for the user\'s profile", "isDeprecated": false, "name": "youtubeIntroUrl", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "User", "possibleTypes": null }, { "description": "A channel moderator", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "canBan", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "canLongTimeout", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "canShortTimeout", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "canUnTimeout", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "canUnban", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "channel", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "Channel", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "user", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "ChannelModerator", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [ { "defaultValue": null, "description": null, "name": "channelId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "defaultValue": null, "description": null, "name": "userId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } } ], "deprecationReason": null, "description": "Ban a user from a chat channel.", "isDeprecated": false, "name": "banUser", "type": { "kind": "OBJECT", "name": "ChannelModerationLog", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "channelId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "defaultValue": null, "description": null, "name": "message", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "INPUT_OBJECT", "name": "ChatMessageInput", "ofType": null } } } ], "deprecationReason": null, "description": "Create a chat message", "isDeprecated": false, "name": "createChatMessage", "type": { "kind": "OBJECT", "name": "ChatMessage", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "channelId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "defaultValue": null, "description": null, "name": "messageId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } } ], "deprecationReason": null, "description": "Deletes a specfic chat message from channel.", "isDeprecated": false, "name": "deleteMessage", "type": { "kind": "OBJECT", "name": "ChannelModerationLog", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "streamId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } } ], "deprecationReason": null, "description": "End a stream", "isDeprecated": false, "name": "endStream", "type": { "kind": "OBJECT", "name": "Stream", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "metadata", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "INPUT_OBJECT", "name": "StreamMetadataInput", "ofType": null } } }, { "defaultValue": null, "description": null, "name": "streamId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } } ], "deprecationReason": null, "description": "Update a stream\'s metadata", "isDeprecated": false, "name": "logStreamMetadata", "type": { "kind": "OBJECT", "name": "StreamMetadata", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "channelId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "defaultValue": null, "description": null, "name": "userId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } } ], "deprecationReason": null, "description": "Long timeout (15 minutes) a user from a chat channel.", "isDeprecated": false, "name": "longTimeoutUser", "type": { "kind": "OBJECT", "name": "ChannelModerationLog", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "channelId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "defaultValue": null, "description": null, "name": "userId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } } ], "deprecationReason": null, "description": "Short timeout (5 minutes) a user from a chat channel.", "isDeprecated": false, "name": "shortTimeoutUser", "type": { "kind": "OBJECT", "name": "ChannelModerationLog", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "channelId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } } ], "deprecationReason": null, "description": "Start a stream", "isDeprecated": false, "name": "startStream", "type": { "kind": "OBJECT", "name": "Stream", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "channelId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "defaultValue": null, "description": null, "name": "userId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } } ], "deprecationReason": null, "description": "Unban a user from a chat channel.", "isDeprecated": false, "name": "unbanUser", "type": { "kind": "OBJECT", "name": "ChannelModerationLog", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "streamId", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "ID", "ofType": null } } }, { "defaultValue": null, "description": null, "name": "thumbnail", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "Upload", "ofType": null } } } ], "deprecationReason": null, "description": "Update a stream\'s thumbnail", "isDeprecated": false, "name": "uploadStreamThumbnail", "type": { "kind": "OBJECT", "name": "Stream", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "RootMutationType", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": "List all categories", "isDeprecated": false, "name": "categories", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "Category", "ofType": null } } }, { "args": [ { "defaultValue": null, "description": null, "name": "slug", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "deprecationReason": null, "description": "Query individual category", "isDeprecated": false, "name": "category", "type": { "kind": "OBJECT", "name": "Category", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "hmacKey", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "defaultValue": null, "description": null, "name": "username", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "deprecationReason": null, "description": "Query individual channel", "isDeprecated": false, "name": "channel", "type": { "kind": "OBJECT", "name": "Channel", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "categorySlug", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "status", "type": { "kind": "ENUM", "name": "ChannelStatus", "ofType": null } } ], "deprecationReason": null, "description": "List all channels", "isDeprecated": false, "name": "channels", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "Channel", "ofType": null } } }, { "args": [ { "defaultValue": null, "description": null, "name": "streamerUsername", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "userUsername", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "deprecationReason": null, "description": "List all follows or followers", "isDeprecated": false, "name": "followers", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "Follower", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "Get yourself", "isDeprecated": false, "name": "myself", "type": { "kind": "OBJECT", "name": "User", "ofType": null } }, { "args": [ { "defaultValue": null, "description": null, "name": "streamerUsername", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "userUsername", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "deprecationReason": null, "description": "List all subscribers or subscribees", "isDeprecated": false, "name": "subscriptions", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "Sub", "ofType": null } } }, { "args": [ { "defaultValue": null, "description": null, "name": "id", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "username", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "deprecationReason": null, "description": "Query individual user", "isDeprecated": false, "name": "user", "type": { "kind": "OBJECT", "name": "User", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "List all users", "isDeprecated": false, "name": "users", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "RootQueryType", "possibleTypes": null }, { "description": "The `String` scalar type represents textual data, represented as UTF-8\\ncharacter sequences. The String type is most often used by GraphQL to\\nrepresent free-form human-readable text.", "enumValues": null, "fields": null, "inputFields": null, "interfaces": null, "kind": "SCALAR", "name": "String", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "deprecationReason", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "description", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "isDeprecated", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "name", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "__EnumValue", "possibleTypes": null }, { "description": "Tags are user created labels that are either global or category specific.", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "category", "type": { "kind": "OBJECT", "name": "Category", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "The number of streams started with this tag", "isDeprecated": false, "name": "countUsage", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "Name of the tag", "isDeprecated": false, "name": "name", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "URL friendly name of the tag", "isDeprecated": false, "name": "slug", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "Tag", "possibleTypes": null }, { "description": "Represents an uploaded file.\\n", "enumValues": null, "fields": null, "inputFields": null, "interfaces": null, "kind": "SCALAR", "name": "Upload", "possibleTypes": null }, { "description": "Represents scalars, interfaces, object types, unions, enums in the system", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "description", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [ { "defaultValue": "false", "description": null, "name": "includeDeprecated", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "enumValues", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "__EnumValue", "ofType": null } } }, { "args": [ { "defaultValue": "false", "description": null, "name": "includeDeprecated", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } } ], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "fields", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "__Field", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "inputFields", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "__InputValue", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "interfaces", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "__Type", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "kind", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "name", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "ofType", "type": { "kind": "OBJECT", "name": "__Type", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "possibleTypes", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "__Type", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "__Type", "possibleTypes": null }, { "description": "The `DateTime` scalar type represents a date and time in the UTC\\ntimezone. The DateTime appears in a JSON response as an ISO8601 formatted\\nstring, including UTC timezone (\\"Z\\"). The parsed date and time string will\\nbe converted to UTC if there is an offset.", "enumValues": null, "fields": null, "inputFields": null, "interfaces": null, "kind": "SCALAR", "name": "DateTime", "possibleTypes": null }, { "description": "Categories are the containers for live streaming content.", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Name of the category", "isDeprecated": false, "name": "name", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": "All categories are now parents and the children are tags.", "description": null, "isDeprecated": true, "name": "parent", "type": { "kind": "OBJECT", "name": "Category", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "Slug of the category", "isDeprecated": false, "name": "slug", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "subcategories", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "Subcategory", "ofType": null } } }, { "args": [], "deprecationReason": "Tag name is now just name", "description": null, "isDeprecated": true, "name": "tagName", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "tags", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "Tag", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "Category", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": null, "inputFields": [ { "defaultValue": null, "description": null, "name": "audioCodec", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "ingestServer", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "ingestViewers", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "lostPackets", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "nackPackets", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "recvPackets", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "sourceBitrate", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "sourcePing", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "streamTimeSeconds", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "vendorName", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "vendorVersion", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "videoCodec", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "defaultValue": null, "description": null, "name": "videoHeight", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "defaultValue": null, "description": null, "name": "videoWidth", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } } ], "interfaces": null, "kind": "INPUT_OBJECT", "name": "StreamMetadataInput", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "args", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "__InputValue", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "deprecationReason", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "description", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "isDeprecated", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "name", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "type", "type": { "kind": "OBJECT", "name": "__Type", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "__Field", "possibleTypes": null }, { "description": "The `ID` scalar type represents a unique identifier, often used to\\nrefetch an object or as key for a cache. The ID type appears in a JSON\\nresponse as a String; however, it is not intended to be human-readable.\\nWhen expected as an input type, any string (such as `\\"4\\"`) or integer\\n(such as `4`) input value will be accepted as an ID.", "enumValues": null, "fields": null, "inputFields": null, "interfaces": null, "kind": "SCALAR", "name": "ID", "possibleTypes": null }, { "description": "A channel is a user\'s actual container for live streaming.", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "bans", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "ChannelBan", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "blockLinks", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "category", "type": { "kind": "OBJECT", "name": "Category", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "chatMessages", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "ChatMessage", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "chatRulesHtml", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "chatRulesMd", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "disableHyperlinks", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "hmacKey", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "inaccessible", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": "The language a user can expect in the stream.", "isDeprecated": false, "name": "language", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "minimumAccountAge", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "moderationLogs", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "ChannelModerationLog", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "moderators", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "ChannelModerator", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "requireConfirmedEmail", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "status", "type": { "kind": "ENUM", "name": "ChannelStatus", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "stream", "type": { "kind": "OBJECT", "name": "Stream", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "streamKey", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "streamer", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "subcategory", "type": { "kind": "OBJECT", "name": "Subcategory", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "tags", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "Tag", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "thumbnail", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "The title of the current stream, live or offline.", "isDeprecated": false, "name": "title", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": "Please use the streamer field", "description": null, "isDeprecated": true, "name": "user", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "Channel", "possibleTypes": null }, { "description": "A single instance of stream metadata.", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "audioCodec", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "ingestServer", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "ingestViewers", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "lostPackets", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "nackPackets", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "recvPackets", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "sourceBitrate", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "sourcePing", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "stream", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "Stream", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "streamTimeSeconds", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "vendorName", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "vendorVersion", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "videoCodec", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "videoHeight", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "videoWidth", "type": { "kind": "SCALAR", "name": "Int", "ofType": null } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "StreamMetadata", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": null, "inputFields": [ { "defaultValue": null, "description": null, "name": "message", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "interfaces": null, "kind": "INPUT_OBJECT", "name": "ChatMessageInput", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "src", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "text", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "type", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "url", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "inputFields": null, "interfaces": [ { "kind": "INTERFACE", "name": "ChatMessageToken", "ofType": null } ], "kind": "OBJECT", "name": "EmoteToken", "possibleTypes": null }, { "description": "The `Int` scalar type represents non-fractional signed whole numeric values.\\nInt can represent values between `-(2^53 - 1)` and `2^53 - 1` since it is\\nrepresented in JSON as double-precision floating point numbers specified\\nby [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).", "enumValues": null, "fields": null, "inputFields": null, "interfaces": null, "kind": "SCALAR", "name": "Int", "possibleTypes": null }, { "description": null, "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "text", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "type", "type": { "kind": "SCALAR", "name": "String", "ofType": null } } ], "inputFields": null, "interfaces": null, "kind": "INTERFACE", "name": "ChatMessageToken", "possibleTypes": [ { "kind": "OBJECT", "name": "EmoteToken", "ofType": null }, { "kind": "OBJECT", "name": "TextToken", "ofType": null }, { "kind": "OBJECT", "name": "UrlToken", "ofType": null } ] }, { "description": null, "enumValues": [ { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "ARGUMENT_DEFINITION" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "ENUM" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "ENUM_VALUE" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "FIELD" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "FIELD_DEFINITION" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "FRAGMENT_DEFINITION" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "FRAGMENT_SPREAD" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "INLINE_FRAGMENT" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "INPUT_FIELD_DEFINITION" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "INPUT_OBJECT" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "INTERFACE" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "MUTATION" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "OBJECT" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "QUERY" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "SCALAR" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "SCHEMA" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "SUBSCRIPTION" }, { "deprecationReason": null, "description": null, "isDeprecated": false, "name": "UNION" } ], "fields": null, "inputFields": null, "interfaces": null, "kind": "ENUM", "name": "__DirectiveLocation", "possibleTypes": null }, { "description": "Represents a schema", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "directives", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "__Directive", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "mutationType", "type": { "kind": "OBJECT", "name": "__Type", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "queryType", "type": { "kind": "OBJECT", "name": "__Type", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "subscriptionType", "type": { "kind": "OBJECT", "name": "__Type", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "types", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "OBJECT", "name": "__Type", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "__Schema", "possibleTypes": null }, { "description": "A moderation event that happened", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "action", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "channel", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "Channel", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "moderator", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "user", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "ChannelModerationLog", "possibleTypes": null }, { "description": "A chat message sent to a channel by a user.", "enumValues": null, "fields": [ { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "channel", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "Channel", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "id", "type": { "kind": "SCALAR", "name": "ID", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "insertedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": "We\'re going to replace this shortly after launch", "description": "Was this message generated by our system for a follow", "isDeprecated": true, "name": "isFollowedMessage", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": "We\'re going to replace this shortly after launch", "description": "Was this message generated by our system for a subscription", "isDeprecated": true, "name": "isSubscriptionMessage", "type": { "kind": "SCALAR", "name": "Boolean", "ofType": null } }, { "args": [], "deprecationReason": null, "description": "The chat message.", "isDeprecated": false, "name": "message", "type": { "kind": "SCALAR", "name": "String", "ofType": null } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "tokens", "type": { "kind": "LIST", "name": null, "ofType": { "kind": "INTERFACE", "name": "ChatMessageToken", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "updatedAt", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "SCALAR", "name": "NaiveDateTime", "ofType": null } } }, { "args": [], "deprecationReason": null, "description": null, "isDeprecated": false, "name": "user", "type": { "kind": "NON_NULL", "name": null, "ofType": { "kind": "OBJECT", "name": "User", "ofType": null } } } ], "inputFields": null, "interfaces": [], "kind": "OBJECT", "name": "ChatMessage", "possibleTypes": null } ] } } } }); // Sets the settings to a dark color // var menuThingy = document.getElementsByClassName("menu-content"); // menuThingy[0].style.backgroundColor = "#0e1726"; // Sets the navbar to the left. Doesn\'t do much, just gives appearance of more space. // var navBar = document.getElementsByTagName("nav"); // navBar[0].style.left = 0; // dark colors // var voyagerPanel = document.getElementsByClassName("doc-navigation"); //voyagerPanel[0].style.background = "#0e1726" // var voyagerPanel = document.getElementsByClassName("scroll-area"); // voyagerPanel[0].style.background = "#0e1726"; // var voyagerPanel = document.getElementsByClassName("contents"); // voyagerPanel[0].style.background = "#0e1726" // var voyagerPanel = document.getElementsByClassName("doc-panel"); // voyagerPanel[0].style.position = "absolute" // Makes the panel draggable, hopefully users will move it to a better position. // dragElement(voyagerPanel[0]); function dragElement(elmnt) { var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; elmnt.onmousedown = dragMouseDown; function dragMouseDown(e) { e = e || window.event; e.preventDefault(); // get the mouse cursor position at startup: pos3 = e.clientX; pos4 = e.clientY; document.onmouseup = closeDragElement; // call a function whenever the cursor moves: document.onmousemove = elementDrag; } function elementDrag(e) { e = e || window.event; e.preventDefault(); // calculate the new cursor position: pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY; pos3 = e.clientX; pos4 = e.clientY; // set the element\'s new position: elmnt.style.top = (elmnt.offsetTop - pos2) + "px"; elmnt.style.left = (elmnt.offsetLeft - pos1) + "px"; } function closeDragElement() { // stop moving when mouse button is released: document.onmouseup = null; document.onmousemove = null; } }  '}),a.add({id:9,href:'/api-docs/docs/authentication/accesstoken/accesstoken/',title:"Access Token",section:"Access Token",content:"Access Tokens #  An access token can be used to query the Glimesh API on behalf of a user. You can also get info about the user that the token belongs to.\n This guide is for getting a token from a real user. If you are just testing or don\u0026rsquo;t want to setup authentication yet you can use client credentials\n Requesting A Token #  Before requesting a token you must have a developer application. You will need your client ID, secret ID, and redirect URL. First you need to have a user authenticate with your app. The user must be directed to\nhttps://glimesh.tv/oauth/authorize?response_type=code\u0026amp;state=\u0026amp;client_id=CLIENT_ID\u0026amp;scope=public%20email%20chat%20streamkey\u0026amp;redirect_uri=REDIRECT_URL Make sure to replace your client ID and your redirect URL. The redirect URL must match one of the URL\u0026rsquo;s on your application. Scopes are space separated values that determine what permissions you want from the user. Only request the scopes that you need.\nThe current scopes are:\n public: Get public information about the user and other users on Glimesh. email: View the email of the user. chat: View and speak in a chatroom. Note that speaking through the api is not yet supported. stream View the streamkey of the user.  When the user is sent to the link they will have to accept your app scopes. They will then be sent to your apps redirect URL. Glimesh will send a code inside the URL when they are sent back to your app. You need to extract it from the URL.\nhttp://your-app.com/some/area?code=qwertyuiop123 Once you have the code you need to make a request to Glimesh. We will exchange the code for an access token.\nPOST https://glimesh.tv/api/oauth/token?grant_type=authorization_code\u0026amp;code=CODE\u0026amp;redirect_uri=REDIRECT_URL\u0026amp;client_id=CLIENTID\u0026amp;client_secret=SECRETID Send a POST request with the URL above replacing the code,redirect url, client ID, and secret ID. Remember to keep the secret ID hidden from your users. When Glimesh receives the POST request it will send back the information we want. Once it is parsed it will look like this:\n{ access_token: \u0026#39;qwertyuiopo1234567890\u0026#39;, created_at: \u0026#39;2020-12-14T15:15:29\u0026#39;, expires_in: 21600, refresh_token: \u0026#39;qwertyuiop0987654321\u0026#39;, scope: \u0026#39;public email chat streamkey\u0026#39;, token_type: \u0026#39;bearer\u0026#39; } Now you can query the Glimesh API on behalf of a user. This token will expire after a few hours so you need to refresh it or ask the user for a new one. If you have any questions talk to us in the #dev channel in our Discord.\n Ready to refresh your token? Continue with OAuth here\n Common Errors #  There are a few errors you may encounter while requesting a token.\n{ error: \u0026#39;invalid_grant\u0026#39;, error_description: \u0026#39;The provided authorization grant is invalid, expired, revoked, does not match the redirection URI used in the authorization request, or was issued to another client.\u0026#39; } This means something is wrong with your URL. You can only use each code once. You must send the request with the grant_type=authorization_code for Glimesh to send you the access token. Ensure all of the data in the URL matches the data in your dev application. Glimesh will refuse any request that is not properly formatted.\n{ error: \u0026#39;invalid_request\u0026#39;, error_description: \u0026#39;The request is missing a required parameter, includes an unsupported parameter value, or is otherwise malformed.\u0026#39; } This is a request error. Some part of your URL is not necessary or missing. Ensure the parameters in the URL are spelled correctly. You should also check that you have all of the required data in the URL.\nError: 401 Unauthorized. You must be logged in to access the API.\nThis is an authentication issue. This is commonly seen when querying the API but I added it here because it most likely means you must request another token. You must renew or request a new token and send the API request to Glimesh properly. Tokens expire after a few hours unless they are renewed.\n Stuck with something? Talk to us in Discord. We would be happy to help you!\n "}),a.add({id:10,href:'/api-docs/docs/authentication/accesstoken/nodejs/node-access-token/',title:"Node Access Token",section:"Access Token",content:"Getting User Tokens With NodeJS #  This is a basic tutorial for getting an auth token from a user using Oauth with NodeJS. This guide assumes you know basic JS and understand the workings of Oauth 2.\n Need a refresh? This tutorial explains the basics of Oauth 2 https://darutk.medium.com/the-simplest-guide-to-oauth-2-0-8c71bd9a15bb\n Creating the Project #  We need to create a basic project. In your terminal type:\nnpm init -y\nThis will create a project.JSON file. This project uses the Express and Request packages. Install them with:\nnpm install express request\nThese packages will help us set up a basic web server and send requests to Glimesh.\nStarting Up #  In your project create a blank JS file. I will title mine auth.js. Start by importing Express. Paste this at the top of your file.\nconst express = require(\u0026#39;express\u0026#39;); //Express package const app = express(); // Creates endpoints for the server. const request = require(\u0026#39;request\u0026#39;); //Request package var clientID = \u0026#34;\u0026#34;; // ID for connecting your users to your app. var secretID = \u0026#34;\u0026#34;; //ID to verify your app, keep private. var redirectUri = \u0026#34;http://localhost:3000/success\u0026#34;; //The redirect path you want to encode into the auth request  This imports the modules our server will need. The server will use the app variable for creating endpoints. The IDs are used so Glimesh can identify our app. We will insert the IDs later.\nCreating the server #  First we need to tell the server to listen for connections. We also need to tell the server which port to be on. I would recommend 8080 or 3000. Paste this in your file:\nconst port = process.env.PORT || 3000; //Opens the server on port 3000 app.listen(port, () =\u0026gt; console.log(\u0026#39;App listening on port \u0026#39; + port)); //keeps the server running^  This will keep the server from closing by itself. Now we can create endpoints for our users to connect to. One will redirect to the Glimesh auth page (/oauth/authorize) and the other will handle the auth info sent from Glimesh. You can create a web page for the first endpoint if you wish. For the sake of this tutorial I will keep it a simple redirect. Paste this in your file:\n//When a user visits http://localhost:3000/auth app.get(\u0026#39;/auth\u0026#39;, (req, res) =\u0026gt; { //redirects the user to the glimesh authenication page res.redirect(307, \u0026#39;https://glimesh.tv/oauth/authorize?response_type=code\u0026amp;state=\u0026amp;client_id=\u0026#39; + clientID + \u0026#39;\u0026amp;scope=public%20email%20chat%20streamkey\u0026amp;redirect_uri=\u0026#39; + encodeURIComponent(redirectUri)); }); In this URL we send the client ID, the redirect URL, and a set of scopes that we want access to. We also request a code in the response_type. Next we will create a developer application. This will give us a client ID and a secret ID.\n If you have a web page that you want your users to access when they go to this endpoint you can send it to them by using res.sendFile(\u0026quot;FILE_NAME.html\u0026quot;) You would need to have a button or other method to send them to the authentication page.\n Developer Applications #  Before we can request Oauth permissions we need a developer application. This is what Glimesh will use to authenticate users for your app. It is also how Glimesh can monitor and identify requests you and your users send. Click here to create your developer application.\nSet up your dev application like this. Use a unique name and description. You can update these at any time. Ensure that the homepage of your app is http://localhost:3000 and your redirect link is http://localhost:3000/success. You must replace the port number if you used a different port.\nSave your app when you are finished.\nGetting the Token #  Now that we have a developer app we can update our variables. Set it equal to your client ID and secret ID. It is very important to keep the secret ID hidden from your users. If your ID is leaked you can reset them from the Glimesh dev app page but your users must authenticate again.\nvar clientID = \u0026#34;CLIENT_ID_HERE\u0026#34; var secretID = \u0026#34;SECRET_HERE\u0026#34; We need to create an endpoint for Glimesh to redirect to. In the previous section we told Glimesh to redirect to locahhost:3000/success. Let\u0026rsquo;s create it!\napp.get(\u0026#34;/success\u0026#34;, (req, res) =\u0026gt; { let code = req.query.code; console.log(\u0026#34;The code is \u0026#34; + code); res.send(`\u0026lt;h1\u0026gt;code recieved!\u0026lt;/h1\u0026gt;`) //Sends a confirmation message to the user }); When our user is redirected to our server the token is sent in the URL as ?code=CODE_HERE. We pull the code from URL and log it to the console.\nOnce you have the code you can request the token from Glimesh. This can be done with a simple Request function. When we get a response we parse it and log it to the console. Update the code for the /success endpoint as follows:\napp.get(\u0026#34;/success\u0026#34;, (req, res) =\u0026gt; { let code = req.query.code; console.log(\u0026#34;The code is \u0026#34; + code); res.send(`\u0026lt;h1\u0026gt;Code recieved, requesting token!\u0026lt;/h1\u0026gt;`) //Sends a confirm message to the user  //Now we send this code to Glimesh to ask for a token.  var options = { method: \u0026#39;POST\u0026#39;, body: \u0026#34;\u0026#34;, url: \u0026#34;https://glimesh.tv/api/oauth/token?grant_type=authorization_code\u0026amp;code=\u0026#34; + code + \u0026#34;\u0026amp;redirect_uri=\u0026#34; + encodeURIComponent(redirectUri) + \u0026#34;\u0026amp;client_id=\u0026#34; + clientID + \u0026#34;\u0026amp;client_secret=\u0026#34; + secretID }; request(options, (error, response, body) =\u0026gt; { if (!error \u0026amp;\u0026amp; response.statusCode == 200) { //If all is as it should be  console.log(body); //The unfiltered response  var data = JSON.parse(body); console.log(data) } else { console.log(error) //log any errors  console.log(response.statusCode) console.log(body) } }); }); Save the file when you are finished. Let\u0026rsquo;s test our code! In your terminal type:\nnode FILE_NAME.js\nReplace FILE_NAME with the name of your file. This will start up the web server. Some antivirus programs may block the process because other devices on your network can access this server. Simply allow the port number you used in your antivirus software if this is the case. You may want to restart the server.\nOnce that is complete and the server is running head to http://localhost:3000/auth replacing the port number with the correct port. It will redirect you to your client application page. Accept it and it will redirect you back to your server at the /success endpoint.\n Please note that you must be logged in before authorizing. A bug prevents you from entering your account info and proceeding to the client app screen. If you are not logged in you must sign in and then go back to /auth\n You should see a confirmation message in your browser. The server is now sending the code back to Glimesh to request a token. Check the console in your terminal to see the code!\nYou can use the access_token to query the API on the users behalf. This will expire after a few hours so you will need to refresh the token or get a new one. If you have any question talk to us in the #dev channel in our Discord. We would love to hear what you are making!\nThe full file can be found here.\nconst express = require(\u0026#39;express\u0026#39;); //Express package const app = express(); // Creates endpoints for the server. const request = require(\u0026#39;request\u0026#39;); //Request package var clientID = \u0026#34;\u0026#34;; // ID for connecting your users to your app. var secretID = \u0026#34;\u0026#34;; //ID to verify your app, keep private. var redirectUri = \u0026#34;http://localhost:3000/success\u0026#34;; //The redirect path you want to encode into the auth request  const port = process.env.PORT || 3000; //Opens the server on port 3000 app.listen(port, () =\u0026gt; console.log(\u0026#39;App listening on port \u0026#39; + port)); //keeps the server running^  //When a user visits http://localhost:3000/auth app.get(\u0026#39;/auth\u0026#39;, (req, res) =\u0026gt; { //redirects the user to the glimesh authenication page 	res.redirect(307, \u0026#39;https://glimesh.tv/oauth/authorize?response_type=code\u0026amp;state=\u0026amp;client_id=\u0026#39; + clientID + \u0026#39;\u0026amp;scope=public%20email%20chat%20streamkey\u0026amp;redirect_uri=\u0026#39; + encodeURIComponent(redirectUri)); }); app.get(\u0026#34;/success\u0026#34;, (req, res) =\u0026gt; { let code = req.query.code; console.log(\u0026#34;The code is \u0026#34; + code); res.send(`\u0026lt;h1\u0026gt;Code Recieved!\u0026lt;/h1\u0026gt;`) //Sends a confirm message to the user 	//Now we send this code to Glimesh to ask for a token. 	var options = { method: \u0026#39;POST\u0026#39;, body: \u0026#34;\u0026#34;, url: \u0026#34;https://glimesh.tv/api/oauth/token?grant_type=authorization_code\u0026amp;code=\u0026#34; + code + \u0026#34;\u0026amp;redirect_uri=\u0026#34; + encodeURIComponent(redirectUri) + \u0026#34;\u0026amp;client_id=\u0026#34; + clientID + \u0026#34;\u0026amp;client_secret=\u0026#34; + secretID }; request(options, (error, response, body) =\u0026gt; { //Send glimesh the code for a token in return 	if (!error \u0026amp;\u0026amp; response.statusCode == 200) { //If all is as it should be 	console.log(body); //The unfiltered response 	var data = JSON.parse(body); //The parsed response 	console.log(data) // The data we want! 	} else { console.log(error) //log any errors 	console.log(response.statusCode) //Status code if an error occurs 	console.log(body) //The body for more info 	} }); }); "}),a.add({id:11,href:'/api-docs/docs/authentication/refreshtoken/refreshtoken/',title:"Refresh Token",section:"Refresh Token",content:"Refresh Tokens #  A refresh token allows you to get a new access token without having your user authenticate again. It is a standard part of OAuth 2.\n Looking for authentication flow? Start with access tokens\n Refreshing A Token #  Refresh tokens are sent when you request an access token. You can pull them from the data that Glimesh sends you.\n{ access_token: \u0026#39;qwertyuiopo1234567890\u0026#39;, created_at: \u0026#39;2020-12-14T15:15:29\u0026#39;, expires_in: 21600, refresh_token: \u0026#39;qwertyuiop0987654321\u0026#39;, scope: \u0026#39;public email chat streamkey\u0026#39;, token_type: \u0026#39;bearer\u0026#39; } You can refresh a token at any time. You do not need to wait for the access token to expire. Refresh tokens last for about one year. When you refresh a token you will need all the info from when you requested an access token.\nSend a POST request to:\nhttps://glimesh.tv/api/oauth/token?grant_type=refresh_token\u0026amp;refresh_token=REFRESH_TOKEN\u0026amp;redirect_uri=REDIRECT_URL\u0026amp; client_id=CLIENT_ID\u0026amp;client_secret=SECRET_ID Make sure to replace REFRESH_TOKEN, REDIRECT_URL, CLIENT_ID, and SECRET_ID with their corresponding values. They must match the values that were sent when you requested an access token. If you want new scopes you must request a new token.\nProvided you formatted your request correctly Glimesh will send you back a new refresh token and access token.\n{ \u0026#34;access_token\u0026#34;: \u0026#34;qwertyuioip123456789\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2020-12-21T23:08:22\u0026#34;, \u0026#34;expires_in\u0026#34;: 21600, \u0026#34;refresh_token\u0026#34;: \u0026#34;qwertyuiop098765321\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;public email chat streamkey\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34; } This will allow you to use the new token and continue to query the Glimesh API. You must use the new access token and the new refresh token. You can safely discard the old tokens.\nOther Info #   You cannot get new scopes from refresh tokens. You must make the user authenticate again with the new scopes. Access tokens last for about 6 hours. You can refresh them earlier if needed. Refresh tokens last for about 1 year. If a user revokes your dev app you cannot use the access or refresh tokens. This would require the user to authenticate again.  If you have any questions talk to us in the #dev channel in our Discord.\n"}),a.add({id:12,href:'/api-docs/docs/chat/chat-tokens/',title:"Chat Tokens",section:"Chat",content:"Chat Tokens #  Chat tokens are a different way to handle messages sent from chat. A normal message is just a simple string. A chat token is an array of data that shows you all sorts of information about the message and what it contains.\n This is a continuation of the websocket tutorial. If you have not already completed the tutorial you can do so here. A chat connection is required for this tutorial.\n The Basics #  A chat token is the original message split by several factors.\n Normal text Emotes URL\u0026rsquo;s  Using the token property we can identify information we would previously have had to parse. Normal text is exactly what is sounds like. Emotes are emotes from Glimesh. The URL is included as well as the text to create it :glimsmile: . URL\u0026rsquo;s are also detected separately from text. This information is also provided alongside the default message property. This means you don\u0026rsquo;t have to use chat tokens if you don\u0026rsquo;t want to.\nAs shown in the image above the chat parts contain all the data from the chat message. The original message is above the chat parts.\nBuilding The Query/Subscription #  We need to query chatMessage. We will plan for every possible type of data in a message. If you do not already have a working websocket for Glimesh you need to get one. If you don\u0026rsquo;t want to keep a connection open you can make a normal query to the channel and view the chatMessages property. Either method is valid.\nStart with this subscription\nsubscription{ chatMessage(channelId:6) { message, user { id }, tokens { ...on EmoteToken { src, text, type, url }, ...on TextToken { text, type }, ...on UrlToken { text, type, url } } } } Or use a query.\nquery{ channel(id:6) { chatMessages { message, user { id }, tokens { ...on EmoteToken { src, text, type, url }, ...on TextToken { text, type }, ...on UrlToken { text, type, url } } } } }  Make sure to replace 6 with your channel ID!\n You don\u0026rsquo;t need to request every property, adjust the request as needed.\nThese requests will return the chat message as well as its message parts. The parts are in an array. The array values are generated if the message contains the type requested. If the type does not exist an array value is not generated.\nResponse:\n[ null, null, \u0026#34;__absinthe__:doc:-576460752302054414:1C57C19163D4D59F61626243BCCA79AB4E50D5C4C2BD8BDA0DDCE83517B20C16\u0026#34;, \u0026#34;subscription:data\u0026#34;, { \u0026#34;result\u0026#34;:{ \u0026#34;data\u0026#34;:{ \u0026#34;chatMessage\u0026#34;:{ \u0026#34;message\u0026#34;:\u0026#34;Hello Glimesh Devs :glimsmile:\u0026#34;, \u0026#34;tokens\u0026#34;:[ { \u0026#34;text\u0026#34;:\u0026#34;Hello Glimesh Devs \u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;/emotes/svg/glimsmile.svg\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;:glimsmile:\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;emote\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;https://glimesh.tv/emotes/svg/glimsmile-af9a10c9d4c4181dbd87ab245d3e3bee.svg?vsn=d\u0026#34; } ] } } }, \u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752302054414:1C57C19163D4D59F61626243BCCA79AB4E50D5C4C2BD8BDA0DDCE83517B20C16\u0026#34; } ]  Message: Hello Glimesh Devs :glimsmile:\n Your response will vary slightly depending on the message and the query.\nFAQ #  Q: What happens if I use a nonexistent emote? :fakeemote:\n A: Glimesh will realize the emote is not real and detect it as text.\n Q: What is the difference between this and the normal chat API?\n A: This version is more advanced and all the parsing is done for you.\n Q: Should I switch to chat parts?\n A: That depends on your project. The normal chat API isn\u0026rsquo;t going away so you can use whichever method you like.\n If you have more questions feel free to talk to us in our discord!\n"}),a.add({id:13,href:'/api-docs/docs/chat/moderation/',title:"Moderation",section:"Chat",content:"Chat Moderation #  Using the Glimesh API we can use mod features such as timeouts and bans. These are critical for chatbots and other services. Before starting this tutorial you should have a working connection to the API and understand basic GraphQL.\n New to GraphQL? This tutorial explains the basics. https://graphql.org/learn/schema/\n  If you are looking for live updates related to moderation you can apply the queries in this tutorial to our Live Updates tutorial here.\n Understanding Mod Actions #  Glimesh has various methods to help streamers moderate their chat. All of the below methods are useable through the API.\n   Action Result     banUser Bans the user from the channel.   unbanUser Removes the ban on a user.   longTimeoutUser Prevents a user from typing for 15 minutes.   shortTimeoutUser Prevents a user from typing for 5 minutes.   deleteMessage Removes a message from chat.    To use any of these methods you must have the proper rank in the chat. You need to be a streamer or a moderator in their chat. You also need the user ID of the user who will receive the action and the channel ID of the channel in which the action will take place. You can get a channel ID with the below query.\nquery { channel(username: \u0026#34;NAMEHERE\u0026#34;) { id } } A user ID can be attained from various queries. Since you are likely in a chat you can pull the ID from the chatMessage event. Your subscription to a chat (to listen for chat messages) would look something like this.\nsubscription { chatMessage(channelId:6) { message, user { id } } } The message would be the chat message and the ID in the user object would be the ID of the user who sent the message.\n There is also an ID property in the chatMessage. This is the ID of the message, not a user or channel ID. Don\u0026rsquo;t get them confused!\n Connection #  Now that we have a method to get the user and channel IDs we can start banning everyone moderating!\n Memes aside, you always need to use the API responsibly. Bots, AI, and message parsing can fail and you never want to wrongly ban a user. Always ensure that any automated services log all their actions. You may need to go back and unban someone if a mistake is made.\n For testing purposes you should use your own channel and a bot account. You can ban yourself but it\u0026rsquo;s easier to use a different account. Glimesh uses mutations to moderate users. Mutations can be sent in http or websocket form. If you are in chat it is best to use the websocket since a connection would already be open.\nTimeouts #  Send this to the API to timeout a user for 5 minutes.\nmutation { shortTimeoutUser(channelId:6, userId:201) { action, moderator {displayname}, } }  You need to replace 6 and 201 with the proper IDs.\n A long timeout is very similar. This will last for 15 minutes.\nmutation { longTimeoutUser(channelId:6, userId:201) { action, moderator {displayname}, } } Bans #  Banning users works the same way. Simply replace the timeout mutation with the ban mutation.\nmutation { banUser(channelId:6, userId:201) { action, moderator {displayname} } } If you need to unban a user you can use this mutation.\nmutation { unbanUser(channelId:6, userId:201) { action, moderator {displayname} } } Delete Messages #  You can also delete messages. You need the channel ID and the message ID. The message ID can be attained by querying the messages in a channel or by requesting it in a chatMessage subscription. Use this mutation to delete a message.\nmutation { deleteMessage(channelId:6, messageId: 111) { action, moderator { displayname } } } Attempting to unban a user that is not banned will return an internal server error. Attempting to use any moderator action on a user or message that does not exist will return \u0026ldquo;not found\u0026rdquo;. Using moderator actions in a channel that you do not have the authorization will result in an error. If you need more information about what properties you can receive from a moderator action check out the moderator reference. It provides a list of all the properties you can request. Glimesh.tv/api has a full list of all the API features.\nModeration Log #  Glimesh stores a copy of all the moderation events that happen to a user. This log can be viewed by the streamer here. We can also access this log via the API. Unlike the webpage, this log can be viewed by any user! Let\u0026rsquo;s create a basic query.\nquery { channel(id:6) { moderationLogs { action, moderator {username} } } } This will return an array of data showing the moderation log.\n{ \u0026#34;data\u0026#34;: { \u0026#34;channel\u0026#34;: { \u0026#34;moderationLogs\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;short_timeout\u0026#34;, \u0026#34;moderator\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } }, { \u0026#34;action\u0026#34;: \u0026#34;short_timeout\u0026#34;, \u0026#34;moderator\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } }, { \u0026#34;action\u0026#34;: \u0026#34;long_timeout\u0026#34;, \u0026#34;moderator\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } }, { \u0026#34;action\u0026#34;: \u0026#34;long_timeout\u0026#34;, \u0026#34;moderator\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } }, { \u0026#34;action\u0026#34;: \u0026#34;ban\u0026#34;, \u0026#34;moderator\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } }, { \u0026#34;action\u0026#34;: \u0026#34;unban\u0026#34;, \u0026#34;moderator\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } } ] } } } That is the basis for using moderation actions with the API. All of the above queries and mutations can be done through a websocket connection as well as a normal query.\nIf you have any questions talk to us in the #dev channel in our Discord.\n"}),a.add({id:14,href:'/api-docs/docs/chat/mutations/',title:"Mutations",section:"Chat",content:"Chat Mutations #  This tutorial will enable you to query and send messages to the chat using the Glimesh API. If you are looking to build a chatbot or other program that needs a constant connection view this tutorial. To connect to a chat you will need an access token or a client ID. Keep in mind that using a client ID will keep you in read-only mode for chat environments. The access token must have the chat scope to post messages.\n If you are testing you can use client credentials to get an access token. This will allow you to talk as your own account without going through the entire auth process.\n Starting Up #  Since we are not using a websocket connection we have to manually query and send chat messages. This is done through the Glimesh API. We can query any channel for chat messages. We can also send messages to any channel that we choose. Understanding how API requests work will be important for completing this tutorial.\n New to the API? Read this before starting.\n Authentication #  All API requests must contain the proper authentication. The authentication value should be included as a header of the request. This value will change depending on the authentication type. For access tokens use:\nAuthorization: Bearer YOUR_TOKEN .\nReplace YOUR_TOKEN with your access token. If you are using a client ID to authenticate you must use this instead:\nAuthorization: Client-ID YOUR_CLIENT_ID\nReplace YOUR_CLIENT_ID with your ID. This will allow you access to the API.\n A client ID can only use the API in read only mode. An access token must have the chat scope.\n Querying Existing Messages #  We need to set up a query to gather the chat messages. You will need the channel ID of a streamer to get the messages. You can get a channel ID with this query. Replace Mytho with the name of the user that you want the ID from.\nquery { channel(username: \u0026#34;Mytho\u0026#34;) { id } } Once you have the ID we can build our request. The query needs to be in the body of the request. You must send the query as a POST request. Structure it as follows:\nquery { channel(id:ID) { chatMessages { message, user { username, avatarUrl } } } }  Don\u0026rsquo;t forget to replace ID with the channel ID! If you want more data you can view the chatMessage reference here\n Glimesh will respond with a set of JSON data. You need to parse it to get the data that you want.\n{ \u0026#34;data\u0026#34;: { \u0026#34;channel\u0026#34;: { \u0026#34;chatMessages\u0026#34;: [ { \u0026#34;message\u0026#34;: \u0026#34;Glimesh is pretty great!\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://glimesh-user-assets.nyc3.cdn.digitaloceanspaces.com/uploads/avatars/Mytho.png?v=63762672056\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } }, { \u0026#34;message\u0026#34;: \u0026#34;Hello there\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://glimesh-user-assets.nyc3.cdn.digitaloceanspaces.com/uploads/avatars/Mytho.png?v=63762672056\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } }, // and so on... Sending Messages #  The Glimesh API uses mutations to send messages. The request must contain this mutation with a channel ID and a chat message. Structure it as show below. Make sure to replace MESSAGE with your chat message and ID with your channel ID.\nmutation { createChatMessage(channelId:6, message: {message: \u0026#34;MESSAGE\u0026#34;}) { message, insertedAt, user { username } } }  This should go in the body of the request.\n Glimesh will return with the message that was sent to chat. If you want more data you have to request it. The chatMessage reference can be found here.\n{ \u0026#34;data\u0026#34;: { \u0026#34;createChatMessage\u0026#34;: { \u0026#34;insertedAt\u0026#34;: \u0026#34;2021-01-08T05:03:44\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;MESSAGE\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;AFaithfulServant\u0026#34; } } } } This is all of the info required to interact with the chat API. Although this is a viable method, using websockets is the standard way of connecting to the chat. Websockets provide a constant connection and eliminates the need to query the API for new information. This is essential for services such as chatbots. If you have any questions talk to us in our discord.\n"}),a.add({id:15,href:'/api-docs/docs/chat/projects/sitewidesubscription/',title:"Site Wide Subscription",section:"Projects",content:"Site Wide Chat Messages #  The Glimesh API allows you to subscribe to any channel to listen for chat messages. There is no limit to the amount of channels that you can listen to. In this project we will listen for every chat message from every user across the entire site. Before starting you should fully understand the WebSocket Tutorial.\nFirst we need to open a websocket connection to Glimesh. Use the process from the websocket tutorial linked above to get the connection open. Instead of subscribing to a specific channel you want to subscribe to the chatMessage event. You can do so with this:\n[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;doc\u0026#34;,{\u0026#34;query\u0026#34;:\u0026#34;subscription{ chatMessage { user { username avatar } message } }\u0026#34;}] Normally the event requires a channel ID as a parameter. Since we don\u0026rsquo;t specify which channel to listen to it connects to every channel on the site. All you have to do is log the messages as they come in!\n[null,null,\u0026#34;__absinthe__:doc:-576460752298178591:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;,\u0026#34;subscription:data\u0026#34;,{\u0026#34;result\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;chatMessage\u0026#34;:{\u0026#34;message\u0026#34;:\u0026#34;hello world!\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;avatar\u0026#34;:\u0026#34;/uploads/avatars/Mytho.png?v=63762672056\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;Mytho\u0026#34;}}}},\u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752298178591:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;}] In the example above we requested the message as well as the username and avatar of the chatter. This query shows all of the possible data we can get from a chat message.\nsubscription { chatMessage { id, insertedAt, message, updatedAt, channel { # Channel data }, user { # User data }, tokens { text, type, ...on EmoteToken { src, text, type, url }, ...on TextToken { text, type }, ...on UrlToken { text, type, url } } } } This is all of the info required to listen to every chatroom. If you have any questions talk to us on our Discord.\n"}),a.add({id:16,href:'/api-docs/docs/chat/websockets/',title:"Websockets",section:"Chat",content:"Chat WebSockets #  Glimesh uses WebSockets to allow for constant communication between you and the chat API. To connect to a chat you will need an access token or a client ID. Keep in mind that using a client ID will keep you in read-only mode for chat environments. The access token must have the chat scope to post messages.\n If you are testing you can use client credentials to get an access token. This will allow you to talk as your own account without going through the entire auth process.\n Preparing the Connection #  First, build your URL that you will connect to. It should look like this:\nwss://glimesh.tv/api/socket/websocket?vsn=2.0.0\u0026amp;token=TOKEN_HERE That URL is for access token authentication. If you are using a client ID use this instead:\nwss://glimesh.tv/api/socket/websocket?vsn=2.0.0\u0026amp;client_id=CLIENT_ID  Make sure to replace TOKEN_HERE or CLIENT_ID with the proper token or ID.\n Start by opening a secure websocket connection to the URL you are using. When the connection is opened we send Glimesh a join request in JSON format to stay connected to the socket. The array below is a example of what this should look like.\n[\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;__absinthe__:control\u0026quot;,\u0026quot;phx_join\u0026quot;,{}] Notice that this is a JSON array. Some WebSocket libraries only allow you to send strings or specially formatted JSON. Sometimes you need to encase the data in a string. If the connection closes immediately you may need to change the type of your request. This depends purely on your library, if you are having trouble talk to us in our discord.\n Javascript example using the ws NPM package:\nconnection.send(\u0026#39;[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_join\u0026#34;,{}]\u0026#39;); // Option 1 connection.send(JSON.stringify([\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_join\u0026#34;,{}])); //Preferred option  The first value is the join ref. The second is the normal ref. They can be useful for multi-connections but we will use the value of 1 for all refs in this doc. The third is the topic. The fourth is the event. The fifth is for a payload. Glimesh does not require a payload for this request so we can leave this blank {} .\nIf Glimesh successfully receives our request we will get a response similar to what we sent. Notice that the first two values are the same. The response tells us that Glimesh is ready.\n[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] Joining Chat #  Now that Glimesh has accepted our connection we can connect to a chat. You will need a channel ID for the channel you want to connect to. If you do not know the channel ID you can query the API for it. Simply replace Mytho with the proper user.\nquery { channel(username: \u0026#34;Mytho\u0026#34;) { id } }  Remember: Channel IDs and user IDs are different things. Everyone is a user but not everyone has a channel.\n Once you have the ID we can join the chat. Send this through the connection:\n[\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;__absinthe__:control\u0026quot;,\u0026quot;doc\u0026quot;,{\u0026quot;query\u0026quot;:\u0026quot;subscription{ chatMessage(channelId: 6) { user { username avatar } message } }\u0026quot;,\u0026quot;variables\u0026quot;:{} }] Make sure to replace 6 with your channel ID! The query we just sent will determine what data is sent to us every time a chat message appears in chat. In this example we requested the message and the user who sent it. We ask for the username and avatar of the user in the user object.\n To view a list of everything you can request check out the API docs here (Docs =\u0026gt; subscription =\u0026gt; chatMessage).\n Glimesh will send us a response:\n[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{\u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752303349214:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] Staying Connected (heartbeat) #  Now we are connected to chat! The only thing left to do is send a heartbeat to Glimesh so the connection won\u0026rsquo;t be closed. You need to send a heartbeat every 20 seconds. Structure it as follows:\n[\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;phoenix\u0026quot;,\u0026quot;heartbeat\u0026quot;,{}] Glimesh will respond with:\n[\u0026#34;null\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;phoenix\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] Now Glimesh won\u0026rsquo;t disconnect us and we have a stable chat connection! Next we will parse incoming messages and send messages back to chat.\nIncoming Messages #  First let\u0026rsquo;s handle incoming messages. A chat message sent from the API would look like this:\n[null,null,\u0026#34;__absinthe__:doc:-576460752298178591:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;,\u0026#34;subscription:data\u0026#34;,{\u0026#34;result\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;chatMessage\u0026#34;:{\u0026#34;message\u0026#34;:\u0026#34;hello world!\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;avatar\u0026#34;:\u0026#34;/uploads/avatars/Mytho.png?v=63762672056\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;Mytho\u0026#34;}}}},\u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752298178591:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;}] It is returning the data that we requested when we connected to this channel. The subscription ID helps you keep track of which channel the message is from. When you receive a message you need to parse the JSON data. Then you can get any of the data from the response.\n The chat API is being worked on so the structure will likely change in a future update.\n Sending Messages #  Next we will send a message back to chat. We must use a mutation to do so. Send this to chat:\n[\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;__absinthe__:control\u0026quot;,\u0026quot;doc\u0026quot;,{\u0026quot;query\u0026quot;:\u0026quot;mutation {createChatMessage(channelId:6, message: {message: \\\u0026quot;Hello There!\\\u0026quot;}) {message }}\u0026quot;,\u0026quot;variables\u0026quot;:{}}]  Don\u0026rsquo;t forget to replace 6 with your channel ID and Hello World with your message! The \\ before the quotes are used to prevent the JSON structure from breaking. Depending on how your lib handles ws messages they may not be necessary. The format for sending messages is very strict, ensure Glimesh receives your data as valid JSON.\n Only access tokens with the chat scope can talk in chat. Client IDs are read only. In the above data we requested to have the message returned to us when Glimesh sent it to chat. Glimesh will confirm that the message was received:\n[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;createChatMessage\u0026#34;:{\u0026#34;message\u0026#34;:\u0026#34;Hello There!\u0026#34;}}},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] WebSocket API Queries #  You don\u0026rsquo;t need to disconnect from the connection to make a normal API request. You can send requests from within your websocket connection! As with normal queries you are limited by the scope of your access token or client ID. Let\u0026rsquo;s build a simple request.\nquery { followers(streamerUsername: \u0026#34;CHANNEL\u0026#34;) { id, user { username } } } In this example we request the ID and username of the followers of a channel. Replace CHANNEL with any streamer on Glimesh. Keep in mind that they must be a channel and not just a normal user. Add this query as the payload in the message that we will send to the API. As with all requests we must make this valid JSON before sending it to Glimesh.\n[\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;__absinthe__:control\u0026quot;,\u0026quot;doc\u0026quot;,{\u0026quot;query\u0026quot;:\u0026quot;query {followers(streamerUsername: \\\u0026quot;CHANNEL\\\u0026quot;) {id,user {username}}}\u0026quot;}]  This snippet is already JSON, you may have to make adjustments depending on your websocket library.\n Glimesh will respond:\n[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;followers\u0026#34;:[{\u0026#34;id\u0026#34;:\u0026#34;613\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;username\u0026#34;:\u0026#34;Mytho\u0026#34;}},{\u0026#34;id\u0026#34;:\u0026#34;629\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;username\u0026#34;:\u0026#34;TheCat\u0026#34;}},{\u0026#34;id\u0026#34;:\u0026#34;752\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;username\u0026#34;:\u0026#34;Kirby\u0026#34;}},{\u0026#34;id\u0026#34;:\u0026#34;11992\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;username\u0026#34;:\u0026#34;RainbowFist\u0026#34;}}]}},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] This is all the info you will need to connect and use the chat API. If you have any questions talk to us in our discord!\nConnection Issues #  The most common issue is the connection closing with no message as to why. One of two things has happened:\n Heartbeat: You must send a heartbeat message to Glimesh every 30 seconds or Glimesh will drop the connection. Format: The chat API must receive data in the proper format. Most requests will need to be sent in a JSON array. The refs must be surrounded by quotes. The message in the mutation must also contain quotes. You may have to use a backslash to properly format the chat message. \\\u0026quot;message data\\\u0026quot;  "}),a.add({id:17,href:'/api-docs/docs/developerresources/libraries/',title:"Libraries",section:"Developer Resources",content:"Community Libraries #  This is a list of community created libraries to help communicate with the API. All of these libraries are community made and not official in any way.\nNodeJS/TypeScript #  https://www.npmjs.com/package/glimesh-chat\nA library for connecting to chat and using moderator actions such as timeouts and bans.\nAn access token is required to use this module.\nMaintained by Innectic\nC# #  https://www.nuget.org/packages/StreamingClientLibrary.Glimesh/\nA library for connecting to the Glimesh chat API in C#.\nThis library has other functions for subscriptions and queries.\nMaintained by SaviorXTanren\n"}),a.add({id:18,href:'/api-docs/docs/reference/api/',title:"API",section:"Reference",content:"API Requests #  This document shows common API requests that may be of use. To see the most recent version of the API visit https://glimesh.tv/api in the docs section.\nRemove any comments before sending to Glimesh.\nCategory List #  Returns a list of all the categories. Query query { categories { id, # ID of the category name, # Name of the category slug, # Slug of the category (lowercase name) tagName, # The parent and current category: Art \u0026gt; Digital parent { # The parent category. Null if no parent exists. name # all of the above fields are available } } } Response This shows two of the categories returned.\n{ \u0026#34;data\u0026#34;: { \u0026#34;categories\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Gaming\u0026#34;, \u0026#34;parent\u0026#34;: null, \u0026#34;slug\u0026#34;: \u0026#34;gaming\u0026#34;, \u0026#34;tagName\u0026#34;: \u0026#34;Gaming\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;13\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Digital\u0026#34;, \u0026#34;parent\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Art\u0026#34; }, \u0026#34;slug\u0026#34;: \u0026#34;digital\u0026#34;, \u0026#34;tagName\u0026#34;: \u0026#34;Art \u0026gt; Digital\u0026#34; }, ] } }  "}),a.add({id:19,href:'/api-docs/docs/reference/apireference/',title:"API Reference",section:"Reference",content:"Remove any comments before sending to Glimesh.\nCategory List #  Returns a list of all the categories. Query query { categories { id, # ID of the category name, # Name of the category slug, # Slug of the category (lowercase name) tagName, # The parent and current category: Art \u0026gt; Digital parent { # The parent category. Null if no parent exists. name # all of the above fields are available } } } Response This shows two of the categories returned.\n{ \u0026#34;data\u0026#34;: { \u0026#34;categories\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Gaming\u0026#34;, \u0026#34;parent\u0026#34;: null, \u0026#34;slug\u0026#34;: \u0026#34;gaming\u0026#34;, \u0026#34;tagName\u0026#34;: \u0026#34;Gaming\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;13\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Digital\u0026#34;, \u0026#34;parent\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Art\u0026#34; }, \u0026#34;slug\u0026#34;: \u0026#34;digital\u0026#34;, \u0026#34;tagName\u0026#34;: \u0026#34;Art \u0026gt; Digital\u0026#34; }, ] } }  "}),a.add({id:20,href:'/api-docs/docs/reference/channel/',title:"Channel",section:"Reference",content:"Channel Subscription #  Shows all the properties of the channel object. Note that for nested objects only one propery is shown.\nsubscription { channel(id:6) { bans {reason}, category {name}, chatMessages {message}, chatRulesHtml, chatRulesMd, hmacKey, id, inaccessible, insertedAt, language, moderationLogs {action}, moderators {canBan}, status, stream {id}, streamKey, streamer {displayname}, tags {name}, thumbnail, title, updatedAt } } \nA full list of every property can be found on glimesh.tv/api. An interactive version of the API can be found on our voyager page.\n"}),a.add({id:21,href:'/api-docs/docs/reference/channelreference/',title:"Channel Reference",section:"Reference",content:"Shows all the properties of the channel object. Note that for nested objects only one propery is shown.\nsubscription { channel(id:6) { bans {reason}, category {name}, chatMessages {message}, chatRulesHtml, chatRulesMd, hmacKey, id, inaccessible, insertedAt, language, moderationLogs {action}, moderators {canBan}, status, stream {id}, streamKey, streamer {displayname}, tags {name}, thumbnail, title, updatedAt } } "}),a.add({id:22,href:'/api-docs/docs/reference/chat/',title:"Chat",section:"Reference",content:"Chat #  Shows all of the fields in the chatMessage object.\nchatMessage { id, insertedAt, message, updatedAt, channel { // Channel data  }, user { // User data  } } \n"}),a.add({id:23,href:'/api-docs/docs/reference/chatparts/',title:"Chat Parts",section:"Reference",content:"Chat Parts #  All the possbile data to query from a chat part.\nsubscription{ chatMessage(channelId:6) { message, user { id }, tokens { text, type, ...on EmoteToken { src, text, type, url }, ...on TextToken { text, type }, ...on UrlToken { text, type, url } } } } A possible response. (Dependent on query and message)\n[ null, null, \u0026#34;__absinthe__:doc:-576460752302054414:1C57C19163D4D59F61626243BCCA79AB4E50D5C4C2BD8BDA0DDCE83517B20C16\u0026#34;, \u0026#34;subscription:data\u0026#34;, { \u0026#34;result\u0026#34;:{ \u0026#34;data\u0026#34;:{ \u0026#34;chatMessage\u0026#34;:{ \u0026#34;tokens\u0026#34;:[ { \u0026#34;text\u0026#34;:\u0026#34;Hello Glimesh Devs \u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;/emotes/svg/glimsmile.svg\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;:glimsmile:\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;emote\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;https://glimesh.tv/emotes/svg/glimsmile-af9a10c9d4c4181dbd87ab245d3e3bee.svg?vsn=d\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;http://glimdrops.com\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;url\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://glimdrops.com\u0026#34; }, ] } } }, \u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752302054414:1C57C19163D4D59F61626243BCCA79AB4E50D5C4C2BD8BDA0DDCE83517B20C16\u0026#34; } ]  "}),a.add({id:24,href:'/api-docs/docs/reference/chatpartsreference/',title:"Chat Parts Reference",section:"Reference",content:"All the possbile data to query from a chat part.\nsubscription{ chatMessage(channelId:6) { message, user { id }, tokens { text, type, ...on EmoteToken { src, text, type, url }, ...on TextToken { text, type }, ...on UrlToken { text, type, url } } } } A possible response. (Dependent on query and message)\n[ null, null, \u0026#34;__absinthe__:doc:-576460752302054414:1C57C19163D4D59F61626243BCCA79AB4E50D5C4C2BD8BDA0DDCE83517B20C16\u0026#34;, \u0026#34;subscription:data\u0026#34;, { \u0026#34;result\u0026#34;:{ \u0026#34;data\u0026#34;:{ \u0026#34;chatMessage\u0026#34;:{ \u0026#34;tokens\u0026#34;:[ { \u0026#34;text\u0026#34;:\u0026#34;Hello Glimesh Devs \u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;/emotes/svg/glimsmile.svg\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;:glimsmile:\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;emote\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;https://glimesh.tv/emotes/svg/glimsmile-af9a10c9d4c4181dbd87ab245d3e3bee.svg?vsn=d\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;http://glimdrops.com\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;url\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://glimdrops.com\u0026#34; }, ] } } }, \u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752302054414:1C57C19163D4D59F61626243BCCA79AB4E50D5C4C2BD8BDA0DDCE83517B20C16\u0026#34; } ] "}),a.add({id:25,href:'/api-docs/docs/reference/chatreference/',title:"Chat Reference",section:"Reference",content:"Shows all of the fields in the chatMessage object.\nchatMessage { id, insertedAt, message, updatedAt, channel { // Channel data  }, user { // User data  } } "}),a.add({id:26,href:'/api-docs/docs/reference/mod/',title:"Mod",section:"Reference",content:"Mod Reference #  Shows all the queries related to moderation. Note that for nested properties only one property is shown.\nShort and long timeouts have the same properties.\nmutation { shortTimeoutUser(channelId:6, userId:201) { action, channel {id}, insertedAt, moderator {displayname}, updatedAt, user {displayname} } } Banning and unbanning a user have the same properties.\nmutation { banUser(channelId:6, userId:201) { action, channel {id}, insertedAt, moderator {displayname}, updatedAt, user {displayname} } } Deletes a message.\nmutation { deleteMessage(channelId:6, messageId: 999) { action, channel {id}, insertedAt, moderator { displayname }, updatedAt, user { displayname } } } Shows all of the properties for a moderation log.\nquery { channel(id:6) { moderationLogs { action, channel {id}, insertedAt, moderator {username}, updatedAt, user {use} } } } \nA full list of every property can be found on glimesh.tv/api. An interactive version of the API can be found on our voyager page.\n"}),a.add({id:27,href:'/api-docs/docs/reference/modreference/',title:"Mod Reference",section:"Reference",content:"Shows all the queries related to moderation. Note that for nested properties only one property is shown.\nShort and long timeouts have the same properties.\nmutation { shortTimeoutUser(channelId:6, userId:201) { action, channel {id}, insertedAt, moderator {displayname}, updatedAt, user {displayname} } } Banning and unbanning a user have the same properties.\nmutation { banUser(channelId:6, userId:201) { action, channel {id}, insertedAt, moderator {displayname}, updatedAt, user {displayname} } } Deletes a message.\nmutation { deleteMessage(channelId:6, messageId: 999) { action, channel {id}, insertedAt, moderator { displayname }, updatedAt, user { displayname } } } Shows all of the properties for a moderation log.\nquery { channel(id:6) { moderationLogs { action, channel {id}, insertedAt, moderator {username}, updatedAt, user {use} } } } "}),a.add({id:28,href:'/api-docs/docs/reference/scopes/',title:"Scopes",section:"Reference",content:"Scopes #  Scopes are permissions that a developer application requests from a client. The client must approve all of the scopes that you request. You should only request scopes that you plan to use. Below documents all of the available scopes.\n public: Get public information about the user and other users on Glimesh. email: View the email of the user. chat: View and speak in a chatroom. Note that speaking through the api is not yet supported. stream View the streamkey of the user.  Note that more scopes will be added when the chat API is fully complete.\n"}),a.add({id:29,href:'/api-docs/docs/reference/scopesreference/',title:"Scopes Reference",section:"Reference",content:" public: Get public information about the user and other users on Glimesh. email: View the email of the user. chat: View and speak in a chatroom. Note that speaking through the api is not yet supported. stream View the streamkey of the user.  "})})()