'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/api-docs/docs/api/query-api/basic-query/','title':"Basic Query",'section':"Query Api",'content':"Glimesh API Requests #  This is a basic tutorial for communicating with the Glimesh API. This guide assumes you have a client ID or an access token from a user. Having basic GraphQL knowledge would also be helpful.\n New to GraphQL? This tutorial explains the basics. https://graphql.org/learn/schema/\n Authentication #  All requests made to Glimesh must contain the proper authentication. The authentication value should be included as a header of the request. This value will change depending on the authentication type. For access tokens use:\nAuthorization: 'Bearer YOUR_TOKEN' .\nReplace \u0026ldquo;YOUR_TOKEN\u0026rdquo; with your access token. If you are using a client ID to authenticate you must use this instead:\nAuthorization: 'Client-ID YOUR_CLIENT_ID'\nReplace \u0026ldquo;YOUR_CLIENT_ID\u0026rdquo; with your ID. This will allow you access to the API.\n A client ID can use the API in read only mode. An access token is limited by its scopes.\n Building Our Request #  The Glimesh API uses GraphQL. You must structure your query accordingly. The API has documentation here. It will allow you to view all of the possible queries. Some data requires an access token with a special scope. For this example we will structure a basic request that requires no special scope. The query must be included in the body of the request.\nquery { user (username: \u0026#34;USERNAME\u0026#34;){ username, id} } Make sure to change \u0026ldquo;USERNAME\u0026rdquo; to a user on Glimesh. We are requesting the username and ID of the user. Now that we have our authentication and our query we can request the data. Send a POST request with our query and header from above to:\nhttps://glimesh.tv/api\nGlimesh will send a JSON formatted response when it receives our request.\n{ \u0026#34;data\u0026#34;: { \u0026#34;user\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;154\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } } } You can parse the response to get the data you want. You could test every query like this but there is an easier way.\nGlimesh.tv/api #  Glimesh has a website that we can visit to make queries. This is a basic GUI that lets us view the API and has intellisense built in. It is very useful for testing queries.\n You must be logged in to Glimesh for this site to work. You make queries as the authenticated user.\n Visit the website here. You can make any query that you want.\nIn this example we request a list of categories on Glimesh. We specify that we want the name of each. Glimesh will return the data on the right.\nFrom this website you can read the API spec and query for any data that you want. If you have any questions feel free to talk to us in Discord.\nCommon Errors #  There are a few errors you may encounter while querying the API.\nError: 401 Unauthorized. You must be logged in to access the API.\nThis is an authentication issue. Check your authentication header. You need to use the right type of authentication and make sure that the information is valid.\n  Internal Server Error  This is usually user error rather than a server error. Ensure the auth info is correct and check your query for errors. If you think your query is correct try it here.\n  syntax error before: \\\u0026quot;\\\\\\\u0026quot;QUERY\\\\\\\u0026quot;\\\u0026quot;\u0026quot;  Your query is in the incorrect format. It must match the GraphQL specifications. You can only request properties that exist and you must have the proper permissions to access them. Check the API docs for more information.\n Stuck with something? Talk to us in Discord. We would be happy to help you!\n "});index.add({'id':1,'href':'/api-docs/docs/api/query-api/nodejs/node-query/','title':"Node Query",'section':"Query Api",'content':"Glimesh API Requests With NodeJS #  This is a basic tutorial for communicating with the Glimesh API using NodeJS. This guide assumes you know basic JS and have an access token from a user. You can use a client ID if you do not yet have a token. Having basic GraphQL knowledge would also be helpful.\n Need a refresh? This tutorial explains the basics of graphql. https://graphql.org/learn/schema/\n Creating the Project #  We need to create a basic project. In your terminal type\nnpm init -y .\nThis will create a project.JSON file. This project uses the Request npm package. It helps with sending requests to the server and handling the response. In your terminal type\nnpm install request.\nThat is the only package that you will need!\nStarting Up #  In your project create a blank JS file. I will title mine \u0026ldquo;glimesh.js\u0026rdquo;. Start by importing the Request library. Paste this at the top of your file.\nvar request = require('request'); Now we need to build our query. The Glimesh API docs can be found here. It is a work in progress. In this example we will ask Glimesh for the name and ID of our user. If you are using an access token you can get this data in the myself object. query{ myself { username, id } } However, we need to convert this so JS can understand it. To do this we create a data variable. Paste this under the import statement above.\nvar data = ` query { myself { username, id} } ` If you are going to use a client ID you have to specify which user to get data for. This is because a client ID does not have a user identity. This query will return the same data as the myself object.\nvar data = ` query { user (username: \u0026#34;USERNAME\u0026#34;){ username, id} } ` Feel free to replace USERNAME with your own username! Since we are not accessing any private information we do not need any special permissions/scopes.\n Leave the quotations around \u0026quot;USERNAME\u0026quot;. Glimesh processes our query as graphQL. Even though data is a string Glimesh will convert it to graphQL when it receives our request. GraphQL requires that the user we search for be a string. Since we used `` to encase the contents of data, quotations must be used to keep your username a string.\n Define Options #  Next we set up the call to the API. We need to add our data variable from above and our authentication as a header. We do this with the options variable. If you do not already have an authentication method (Client ID or Access Token) you need to get one now. Paste this below your query.\nvar options = { method: \u0026#39;POST\u0026#39;, body: data, url: \u0026#39;https://glimesh.tv/api\u0026#39;, headers: { \u0026#39;Authorization\u0026#39;: \u0026#39;Bearer Your_Token\u0026#39; } }; Notice we are sending the data variable from before. If you are using an access token replace \u0026ldquo;Your_Token\u0026rdquo; with your access token in the Authorization string. It should look like this. 'Authorization': 'Bearer qertyuiop123456789'\nIf you are using a client ID replace \u0026ldquo;Bearer\u0026rdquo; with \u0026ldquo;Client-ID\u0026rdquo; and \u0026ldquo;Your_Token\u0026rdquo; with your client ID. It should look like this.\n'Authorization': 'Client-ID qwertyuiop123456789'\nSend Request #  Now we set up the request. We ask Glimesh for data and we setup a callback function to handle it when it arrives. The server will normally respond in less than one second. Paste this below the options variable.\nfunction callback(error, response, body) { if (!error \u0026amp;\u0026amp; response.statusCode == 200) { //if all works as it should...  console.log(body); //The unfiltered response  var convertedResponse = JSON.parse(body); //Convert the response so we can use it  console.log(`The user is ${convertedResponse.data.myself.username}and the ID is ${convertedResponse.data.myself.id}`); } else { console.log(error) //log any errors.  console.log(body) //sometimes the body contains the error.  } } If you searched for a user instead of myself you need to change the convertedResponse output to:\nconsole.log(`The user ${convertedResponse.data.user.username}has an ID of ${convertedResponse.data.user.id}`); Finally we send the request. At the bottom of the file add this line.\nrequest(options, callback); When you are ready, save the file and type the line below in your terminal to query the API!\nnode filename.js\nMake sure to replace \u0026ldquo;filename\u0026rdquo; with the name of your file! For example -\nnode glimesh.js\nCommon Errors #   You must be logged in to access the API.   Cause: The auth string is incorrect. Make sure the token is valid. They expire after a short period and a new token is needed. You should also check the auth string. It should look like this 'Authorization': 'Bearer qertyuiop123456789' or 'Authorization': 'Client-ID qertyuiop123456789' depending on the auth method you used.\n  Internal Server Error   Cause: This is usually user error rather than a server error. Ensure the auth info is correct and check your query. The query is a string but the contents of that variable are graphQL. If you think your query is correct try it here. Don\u0026rsquo;t forget to remove the `` when testing on the API site. Note that you must be signed in to use the API website!\n  syntax error before: \\\u0026quot;\\\\\\\u0026quot;query\\\\\\\u0026quot;\\\u0026quot;\u0026quot;   Cause: Your query is in the incorrect format. Ensure it matches the example in the code above. You can only request properties that exist and you must have the proper permissions to access them. Check the API docs for more information.\n Conclusion #  This is the basis for most API requests. If you have any questions let us know in the #dev channel in our Discord.\nThe full file can be found here.\nvar request = require(\u0026#39;request\u0026#39;); //Import the library //Define the data we want from Glimesh. var data = ` query { myself { username, id} } ` // If you used a client ID the myself object will not exist. Try this: /* var data = ` query { user (username: \u0026#34;USERNAME\u0026#34;){ username, id} }` */ //Make sure to replace USERNAME with a user!  //Tell the request library where to send the request and how to add auth var options = { method: \u0026#39;POST\u0026#39;, body: data, url: \u0026#39;https://glimesh.tv/api\u0026#39;, headers: { \u0026#39;Authorization\u0026#39;: \u0026#39;Bearer Token_Here\u0026#39; //If you are using a client ID use \u0026#39;Authorization\u0026#39;: \u0026#39;Client-ID qwertyuiop123456789\u0026#39;  } }; //Callback function runs when the data is recieved. We convert it to an object on arrival. function callback(error, response, body) { if (!error \u0026amp;\u0026amp; response.statusCode == 200) { console.log(body); //The unfiltered response  var convertedResponse = JSON.parse(body); //Convert the response  console.log(`You are ${convertedResponse.data.myself.username}and your ID is ${convertedResponse.data.myself.id}`); // If you are using a client ID you will have requested the user object. Use the line below instead!  // console.log(`The user ${convertedResponse.data.user.username} has an ID of ${convertedResponse.data.user.id}`);  } else { console.log(error); //log any errors  console.log(body); } } //send the request request(options, callback); "});index.add({'id':2,'href':'/api-docs/docs/api/voyager/','title':"Voyager",'section':"Api",'content':"Voyager is an interactive GraphQL API explorer. It allows you to view all the data in our API. Click and drag to move around the explorer. Click on a field to view its properties. Scoll to adjust zoom.\nLoading...  // Render GraphQLVoyager.init(document.getElementById('voyager'), { hideDocs: true, hideSettings: true, displayOptions: { sortByAlphabet: true, }, introspection: { \"data\": { \"__schema\": { \"directives\": [ { \"args\": [ { \"defaultValue\": null, \"description\": \"Included when true.\", \"name\": \"if\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"Boolean\", \"ofType\": null } } } ], \"description\": \"Directs the executor to include this field or fragment only when the `if` argument is true.\", \"locations\": [ \"FIELD\", \"FRAGMENT_SPREAD\", \"INLINE_FRAGMENT\" ], \"name\": \"include\" }, { \"args\": [ { \"defaultValue\": null, \"description\": \"Skipped when true.\", \"name\": \"if\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"Boolean\", \"ofType\": null } } } ], \"description\": \"Directs the executor to skip this field or fragment when the `if` argument is true.\", \"locations\": [ \"FIELD\", \"FRAGMENT_SPREAD\", \"INLINE_FRAGMENT\" ], \"name\": \"skip\" } ], \"mutationType\": { \"name\": \"RootMutationType\" }, \"queryType\": { \"name\": \"RootQueryType\" }, \"types\": [ { \"description\": \"Represents a directive\", \"enumValues\": null, \"fields\": [ { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"args\", \"type\": { \"kind\": \"LIST\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"__InputValue\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"description\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"locations\", \"type\": { \"kind\": \"LIST\", \"name\": null, \"ofType\": { \"kind\": \"ENUM\", \"name\": \"__DirectiveLocation\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"name\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": \"Check `locations` field for enum value FIELD\", \"description\": null, \"isDeprecated\": true, \"name\": \"onField\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Boolean\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": \"Check `locations` field for enum value FRAGMENT_SPREAD\", \"description\": null, \"isDeprecated\": true, \"name\": \"onFragment\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Boolean\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": \"Check `locations` field for enum value OPERATION\", \"description\": null, \"isDeprecated\": true, \"name\": \"onOperation\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Boolean\", \"ofType\": null } } ], \"inputFields\": null, \"interfaces\": [], \"kind\": \"OBJECT\", \"name\": \"__Directive\", \"possibleTypes\": null }, { \"description\": null, \"enumValues\": [ { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"ARGUMENT_DEFINITION\" }, { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"ENUM\" }, { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"ENUM_VALUE\" }, { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"FIELD\" }, { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"FIELD_DEFINITION\" }, { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"FRAGMENT_DEFINITION\" }, { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"FRAGMENT_SPREAD\" }, { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"INLINE_FRAGMENT\" }, { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"INPUT_FIELD_DEFINITION\" }, { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"INPUT_OBJECT\" }, { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"INTERFACE\" }, { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"MUTATION\" }, { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"OBJECT\" }, { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"QUERY\" }, { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"SCALAR\" }, { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"SCHEMA\" }, { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"SUBSCRIPTION\" }, { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"UNION\" } ], \"fields\": null, \"inputFields\": null, \"interfaces\": null, \"kind\": \"ENUM\", \"name\": \"__DirectiveLocation\", \"possibleTypes\": null }, { \"description\": null, \"enumValues\": null, \"fields\": [ { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"deprecationReason\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"description\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"isDeprecated\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Boolean\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"name\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } } ], \"inputFields\": null, \"interfaces\": [], \"kind\": \"OBJECT\", \"name\": \"__EnumValue\", \"possibleTypes\": null }, { \"description\": null, \"enumValues\": null, \"fields\": [ { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"args\", \"type\": { \"kind\": \"LIST\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"__InputValue\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"deprecationReason\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"description\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"isDeprecated\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Boolean\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"name\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"type\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"__Type\", \"ofType\": null } } ], \"inputFields\": null, \"interfaces\": [], \"kind\": \"OBJECT\", \"name\": \"__Field\", \"possibleTypes\": null }, { \"description\": null, \"enumValues\": null, \"fields\": [ { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"defaultValue\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"description\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"name\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"type\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"__Type\", \"ofType\": null } } ], \"inputFields\": null, \"interfaces\": [], \"kind\": \"OBJECT\", \"name\": \"__InputValue\", \"possibleTypes\": null }, { \"description\": \"Represents a schema\", \"enumValues\": null, \"fields\": [ { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"directives\", \"type\": { \"kind\": \"LIST\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"__Directive\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"mutationType\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"__Type\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"queryType\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"__Type\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"subscriptionType\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"__Type\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"types\", \"type\": { \"kind\": \"LIST\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"__Type\", \"ofType\": null } } } ], \"inputFields\": null, \"interfaces\": [], \"kind\": \"OBJECT\", \"name\": \"__Schema\", \"possibleTypes\": null }, { \"description\": \"Represents scalars, interfaces, object types, unions, enums in the system\", \"enumValues\": null, \"fields\": [ { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"description\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [ { \"defaultValue\": \"false\", \"description\": null, \"name\": \"includeDeprecated\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Boolean\", \"ofType\": null } } ], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"enumValues\", \"type\": { \"kind\": \"LIST\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"__EnumValue\", \"ofType\": null } } }, { \"args\": [ { \"defaultValue\": \"false\", \"description\": null, \"name\": \"includeDeprecated\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Boolean\", \"ofType\": null } } ], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"fields\", \"type\": { \"kind\": \"LIST\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"__Field\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"inputFields\", \"type\": { \"kind\": \"LIST\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"__InputValue\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"interfaces\", \"type\": { \"kind\": \"LIST\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"__Type\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"kind\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"name\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"ofType\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"__Type\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"possibleTypes\", \"type\": { \"kind\": \"LIST\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"__Type\", \"ofType\": null } } } ], \"inputFields\": null, \"interfaces\": [], \"kind\": \"OBJECT\", \"name\": \"__Type\", \"possibleTypes\": null }, { \"description\": \"The `Boolean` scalar type represents `true` or `false`.\", \"enumValues\": null, \"fields\": null, \"inputFields\": null, \"interfaces\": null, \"kind\": \"SCALAR\", \"name\": \"Boolean\", \"possibleTypes\": null }, { \"description\": \"Categories are the containers for live streaming content.\", \"enumValues\": null, \"fields\": [ { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"id\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"ID\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"Name of the category\", \"isDeprecated\": false, \"name\": \"name\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"Parent category, if null this is a parent category\", \"isDeprecated\": false, \"name\": \"parent\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"Category\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"Slug of the category\", \"isDeprecated\": false, \"name\": \"slug\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"Parent Name and Name of the category in one string\", \"isDeprecated\": false, \"name\": \"tagName\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } } ], \"inputFields\": null, \"interfaces\": [], \"kind\": \"OBJECT\", \"name\": \"Category\", \"possibleTypes\": null }, { \"description\": \"A channel is a user's actual container for live streaming.\", \"enumValues\": null, \"fields\": [ { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"category\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"Category\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"chatMessages\", \"type\": { \"kind\": \"LIST\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"ChatMessage\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"chatRulesHtml\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"chatRulesMd\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"id\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"ID\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"inaccessible\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Boolean\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"insertedAt\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"NaiveDateTime\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"The language a user can expect in the stream.\", \"isDeprecated\": false, \"name\": \"language\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"status\", \"type\": { \"kind\": \"ENUM\", \"name\": \"ChannelStatus\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"stream\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"Stream\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"streamKey\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"streamer\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"User\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"thumbnail\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"The title of the current stream, live or offline.\", \"isDeprecated\": false, \"name\": \"title\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"updatedAt\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"NaiveDateTime\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": \"Please use the streamer field\", \"description\": null, \"isDeprecated\": true, \"name\": \"user\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"User\", \"ofType\": null } } } ], \"inputFields\": null, \"interfaces\": [], \"kind\": \"OBJECT\", \"name\": \"Channel\", \"possibleTypes\": null }, { \"description\": null, \"enumValues\": [ { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"LIVE\" }, { \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"OFFLINE\" } ], \"fields\": null, \"inputFields\": null, \"interfaces\": null, \"kind\": \"ENUM\", \"name\": \"ChannelStatus\", \"possibleTypes\": null }, { \"description\": \"A chat message sent to a channel by a user.\", \"enumValues\": null, \"fields\": [ { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"channel\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"Channel\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"id\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"ID\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"insertedAt\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"NaiveDateTime\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"The chat message.\", \"isDeprecated\": false, \"name\": \"message\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"updatedAt\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"NaiveDateTime\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"user\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"User\", \"ofType\": null } } } ], \"inputFields\": null, \"interfaces\": [], \"kind\": \"OBJECT\", \"name\": \"ChatMessage\", \"possibleTypes\": null }, { \"description\": null, \"enumValues\": null, \"fields\": null, \"inputFields\": [ { \"defaultValue\": null, \"description\": null, \"name\": \"message\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } } ], \"interfaces\": null, \"kind\": \"INPUT_OBJECT\", \"name\": \"ChatMessageInput\", \"possibleTypes\": null }, { \"description\": \"The `DateTime` scalar type represents a date and time in the UTC\\ntimezone. The DateTime appears in a JSON response as an ISO8601 formatted\\nstring, including UTC timezone (\\\"Z\\\"). The parsed date and time string will\\nbe converted to UTC if there is an offset.\", \"enumValues\": null, \"fields\": null, \"inputFields\": null, \"interfaces\": null, \"kind\": \"SCALAR\", \"name\": \"DateTime\", \"possibleTypes\": null }, { \"description\": \"A follower is a user who subscribes to notifications for a particular channel.\", \"enumValues\": null, \"fields\": [ { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"hasLiveNotifications\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Boolean\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"id\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"ID\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"insertedAt\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"NaiveDateTime\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"streamer\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"User\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"updatedAt\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"NaiveDateTime\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"user\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"User\", \"ofType\": null } } } ], \"inputFields\": null, \"interfaces\": [], \"kind\": \"OBJECT\", \"name\": \"Follower\", \"possibleTypes\": null }, { \"description\": \"The `ID` scalar type represents a unique identifier, often used to\\nrefetch an object or as key for a cache. The ID type appears in a JSON\\nresponse as a String; however, it is not intended to be human-readable.\\nWhen expected as an input type, any string (such as `\\\"4\\\"`) or integer\\n(such as `4`) input value will be accepted as an ID.\", \"enumValues\": null, \"fields\": null, \"inputFields\": null, \"interfaces\": null, \"kind\": \"SCALAR\", \"name\": \"ID\", \"possibleTypes\": null }, { \"description\": \"The `Int` scalar type represents non-fractional signed whole numeric values.\\nInt can represent values between `-(2^53 - 1)` and `2^53 - 1` since it is\\nrepresented in JSON as double-precision floating point numbers specified\\nby [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\", \"enumValues\": null, \"fields\": null, \"inputFields\": null, \"interfaces\": null, \"kind\": \"SCALAR\", \"name\": \"Int\", \"possibleTypes\": null }, { \"description\": null, \"enumValues\": null, \"fields\": [ { \"args\": [ { \"defaultValue\": null, \"description\": null, \"name\": \"channelId\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"ID\", \"ofType\": null } } }, { \"defaultValue\": null, \"description\": null, \"name\": \"message\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"INPUT_OBJECT\", \"name\": \"ChatMessageInput\", \"ofType\": null } } } ], \"deprecationReason\": null, \"description\": \"Create a chat message\", \"isDeprecated\": false, \"name\": \"createChatMessage\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"ChatMessage\", \"ofType\": null } }, { \"args\": [ { \"defaultValue\": null, \"description\": null, \"name\": \"streamId\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"ID\", \"ofType\": null } } } ], \"deprecationReason\": null, \"description\": \"End a stream\", \"isDeprecated\": false, \"name\": \"endStream\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"Stream\", \"ofType\": null } }, { \"args\": [ { \"defaultValue\": null, \"description\": null, \"name\": \"metadata\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"INPUT_OBJECT\", \"name\": \"StreamMetadataInput\", \"ofType\": null } } }, { \"defaultValue\": null, \"description\": null, \"name\": \"streamId\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"ID\", \"ofType\": null } } } ], \"deprecationReason\": null, \"description\": \"Update a stream's metadata\", \"isDeprecated\": false, \"name\": \"logStreamMetadata\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"Stream\", \"ofType\": null } }, { \"args\": [ { \"defaultValue\": null, \"description\": null, \"name\": \"channelId\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"ID\", \"ofType\": null } } } ], \"deprecationReason\": null, \"description\": \"Start a stream\", \"isDeprecated\": false, \"name\": \"startStream\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"Stream\", \"ofType\": null } }, { \"args\": [ { \"defaultValue\": null, \"description\": null, \"name\": \"streamId\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"ID\", \"ofType\": null } } }, { \"defaultValue\": null, \"description\": null, \"name\": \"thumbnail\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"Upload\", \"ofType\": null } } } ], \"deprecationReason\": null, \"description\": \"Update a stream's thumbnail\", \"isDeprecated\": false, \"name\": \"uploadStreamThumbnail\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"Stream\", \"ofType\": null } } ], \"inputFields\": null, \"interfaces\": [], \"kind\": \"OBJECT\", \"name\": \"RootMutationType\", \"possibleTypes\": null }, { \"description\": \"The `Naive DateTime` scalar type represents a naive date and time without\\ntimezone. The DateTime appears in a JSON response as an ISO8601 formatted\\nstring.\", \"enumValues\": null, \"fields\": null, \"inputFields\": null, \"interfaces\": null, \"kind\": \"SCALAR\", \"name\": \"NaiveDateTime\", \"possibleTypes\": null }, { \"description\": null, \"enumValues\": null, \"fields\": [ { \"args\": [], \"deprecationReason\": null, \"description\": \"List all categories\", \"isDeprecated\": false, \"name\": \"categories\", \"type\": { \"kind\": \"LIST\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"Category\", \"ofType\": null } } }, { \"args\": [ { \"defaultValue\": null, \"description\": null, \"name\": \"slug\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } } ], \"deprecationReason\": null, \"description\": \"Query individual category\", \"isDeprecated\": false, \"name\": \"category\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"Category\", \"ofType\": null } }, { \"args\": [ { \"defaultValue\": null, \"description\": null, \"name\": \"id\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"ID\", \"ofType\": null } }, { \"defaultValue\": null, \"description\": null, \"name\": \"streamKey\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"defaultValue\": null, \"description\": null, \"name\": \"username\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } } ], \"deprecationReason\": null, \"description\": \"Query individual channel\", \"isDeprecated\": false, \"name\": \"channel\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"Channel\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"List all channels\", \"isDeprecated\": false, \"name\": \"channels\", \"type\": { \"kind\": \"LIST\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"Channel\", \"ofType\": null } } }, { \"args\": [ { \"defaultValue\": null, \"description\": null, \"name\": \"streamerUsername\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"defaultValue\": null, \"description\": null, \"name\": \"userUsername\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } } ], \"deprecationReason\": null, \"description\": \"List all follows or followers\", \"isDeprecated\": false, \"name\": \"followers\", \"type\": { \"kind\": \"LIST\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"Follower\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"Get yourself\", \"isDeprecated\": false, \"name\": \"myself\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"User\", \"ofType\": null } }, { \"args\": [ { \"defaultValue\": null, \"description\": null, \"name\": \"streamerUsername\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"defaultValue\": null, \"description\": null, \"name\": \"userUsername\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } } ], \"deprecationReason\": null, \"description\": \"List all subscribers or subscribees\", \"isDeprecated\": false, \"name\": \"subscriptions\", \"type\": { \"kind\": \"LIST\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"Sub\", \"ofType\": null } } }, { \"args\": [ { \"defaultValue\": null, \"description\": null, \"name\": \"id\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"defaultValue\": null, \"description\": null, \"name\": \"username\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } } ], \"deprecationReason\": null, \"description\": \"Query individual user\", \"isDeprecated\": false, \"name\": \"user\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"User\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"List all users\", \"isDeprecated\": false, \"name\": \"users\", \"type\": { \"kind\": \"LIST\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"User\", \"ofType\": null } } } ], \"inputFields\": null, \"interfaces\": [], \"kind\": \"OBJECT\", \"name\": \"RootQueryType\", \"possibleTypes\": null }, { \"description\": \"A stream is a single live stream in, either current or historical.\", \"enumValues\": null, \"fields\": [ { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"avgChatters\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"avgViewers\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"category\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"Category\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"channel\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"Channel\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"countChatters\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"countViewers\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"endedAt\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"NaiveDateTime\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"id\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"ID\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"insertedAt\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"NaiveDateTime\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"metadata\", \"type\": { \"kind\": \"LIST\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"StreamMetadata\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"newSubscribers\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"peakChatters\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"peakViewers\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"resubSubscribers\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"startedAt\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"NaiveDateTime\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"thumbnail\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"The title of the stream.\", \"isDeprecated\": false, \"name\": \"title\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"updatedAt\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"NaiveDateTime\", \"ofType\": null } } } ], \"inputFields\": null, \"interfaces\": [], \"kind\": \"OBJECT\", \"name\": \"Stream\", \"possibleTypes\": null }, { \"description\": \"A single instance of stream metadata.\", \"enumValues\": null, \"fields\": [ { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"audioCodec\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"id\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"ID\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"ingestServer\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"ingestViewers\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"insertedAt\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"NaiveDateTime\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"lostPackets\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"nackPackets\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"recvPackets\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"sourceBitrate\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"sourcePing\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"stream\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"Stream\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"streamTimeSeconds\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"updatedAt\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"NaiveDateTime\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"vendorName\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"vendorVersion\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"videoCodec\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"videoHeight\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"videoWidth\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } } ], \"inputFields\": null, \"interfaces\": [], \"kind\": \"OBJECT\", \"name\": \"StreamMetadata\", \"possibleTypes\": null }, { \"description\": null, \"enumValues\": null, \"fields\": null, \"inputFields\": [ { \"defaultValue\": null, \"description\": null, \"name\": \"audioCodec\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"defaultValue\": null, \"description\": null, \"name\": \"ingestServer\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"defaultValue\": null, \"description\": null, \"name\": \"ingestViewers\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"defaultValue\": null, \"description\": null, \"name\": \"lostPackets\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"defaultValue\": null, \"description\": null, \"name\": \"nackPackets\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"defaultValue\": null, \"description\": null, \"name\": \"recvPackets\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"defaultValue\": null, \"description\": null, \"name\": \"sourceBitrate\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"defaultValue\": null, \"description\": null, \"name\": \"sourcePing\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"defaultValue\": null, \"description\": null, \"name\": \"streamTimeSeconds\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"defaultValue\": null, \"description\": null, \"name\": \"vendorName\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"defaultValue\": null, \"description\": null, \"name\": \"vendorVersion\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"defaultValue\": null, \"description\": null, \"name\": \"videoCodec\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"defaultValue\": null, \"description\": null, \"name\": \"videoHeight\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"defaultValue\": null, \"description\": null, \"name\": \"videoWidth\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } } ], \"interfaces\": null, \"kind\": \"INPUT_OBJECT\", \"name\": \"StreamMetadataInput\", \"possibleTypes\": null }, { \"description\": \"The `String` scalar type represents textual data, represented as UTF-8\\ncharacter sequences. The String type is most often used by GraphQL to\\nrepresent free-form human-readable text.\", \"enumValues\": null, \"fields\": null, \"inputFields\": null, \"interfaces\": null, \"kind\": \"SCALAR\", \"name\": \"String\", \"possibleTypes\": null }, { \"description\": \"A subscription is an exchange of money for support.\", \"enumValues\": null, \"fields\": [ { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"endedAt\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"DateTime\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"id\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"ID\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"insertedAt\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"NaiveDateTime\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"isActive\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Boolean\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"price\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"Int\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"productName\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"startedAt\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"DateTime\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"streamer\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"User\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"updatedAt\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"SCALAR\", \"name\": \"NaiveDateTime\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"user\", \"type\": { \"kind\": \"NON_NULL\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"User\", \"ofType\": null } } } ], \"inputFields\": null, \"interfaces\": [], \"kind\": \"OBJECT\", \"name\": \"Sub\", \"possibleTypes\": null }, { \"description\": null, \"enumValues\": null, \"fields\": [ { \"args\": [ { \"defaultValue\": null, \"description\": null, \"name\": \"id\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"ID\", \"ofType\": null } } ], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"channel\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"Channel\", \"ofType\": null } }, { \"args\": [ { \"defaultValue\": null, \"description\": null, \"name\": \"channelId\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"ID\", \"ofType\": null } } ], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"chatMessage\", \"type\": { \"kind\": \"OBJECT\", \"name\": \"ChatMessage\", \"ofType\": null } } ], \"inputFields\": null, \"interfaces\": [], \"kind\": \"OBJECT\", \"name\": \"RootSubscriptionType\", \"possibleTypes\": null }, { \"description\": \"Represents an uploaded file.\\n\", \"enumValues\": null, \"fields\": null, \"inputFields\": null, \"interfaces\": null, \"kind\": \"SCALAR\", \"name\": \"Upload\", \"possibleTypes\": null }, { \"description\": \"A user of Glimesh, can be a streamer, a viewer or both!\", \"enumValues\": null, \"fields\": [ { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"avatar\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"avatarUrl\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"confirmedAt\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"NaiveDateTime\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"Exactly the same as the username, but with casing the user prefers\", \"isDeprecated\": false, \"name\": \"displayname\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"id\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"ID\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"HTML version of the user's profile, should be safe for rendering directly\", \"isDeprecated\": false, \"name\": \"profileContentHtml\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"Markdown version of the user's profile\", \"isDeprecated\": false, \"name\": \"profileContentMd\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"Qualified URL for the user's Discord server\", \"isDeprecated\": false, \"name\": \"socialDiscord\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"Qualified URL for the user's Guilded server\", \"isDeprecated\": false, \"name\": \"socialGuilded\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"Qualified URL for the user's Instagram account\", \"isDeprecated\": false, \"name\": \"socialInstagram\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": \"Use the socials field instead\", \"description\": \"Qualified URL for the user's Twitter account\", \"isDeprecated\": true, \"name\": \"socialTwitter\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"Qualified URL for the user's YouTube account\", \"isDeprecated\": false, \"name\": \"socialYoutube\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"A list of linked social accounts for the user\", \"isDeprecated\": false, \"name\": \"socials\", \"type\": { \"kind\": \"LIST\", \"name\": null, \"ofType\": { \"kind\": \"OBJECT\", \"name\": \"UserSocial\", \"ofType\": null } } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"Lowercase user identifier\", \"isDeprecated\": false, \"name\": \"username\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"YouTube Intro URL for the user's profile\", \"isDeprecated\": false, \"name\": \"youtubeIntroUrl\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } } ], \"inputFields\": null, \"interfaces\": [], \"kind\": \"OBJECT\", \"name\": \"User\", \"possibleTypes\": null }, { \"description\": \"A linked social account for a Glimesh user.\", \"enumValues\": null, \"fields\": [ { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"id\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"ID\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"Platform unique identifier, usually a ID, made into a string\", \"isDeprecated\": false, \"name\": \"identifier\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"insertedAt\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"NaiveDateTime\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"Platform that is linked, eg: twitter\", \"isDeprecated\": false, \"name\": \"platform\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": null, \"isDeprecated\": false, \"name\": \"updatedAt\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"NaiveDateTime\", \"ofType\": null } }, { \"args\": [], \"deprecationReason\": null, \"description\": \"Username for the user on the linked platform\", \"isDeprecated\": false, \"name\": \"username\", \"type\": { \"kind\": \"SCALAR\", \"name\": \"String\", \"ofType\": null } } ], \"inputFields\": null, \"interfaces\": [], \"kind\": \"OBJECT\", \"name\": \"UserSocial\", \"possibleTypes\": null } ] } } }, }); // Sets the settings to a dark color // var menuThingy = document.getElementsByClassName(\"menu-content\"); // menuThingy[0].style.backgroundColor = \"#0e1726\"; // Sets the navbar to the left. Doesn't do much, just gives appearance of more space. // var navBar = document.getElementsByTagName(\"nav\"); // navBar[0].style.left = 0; // dark colors // var voyagerPanel = document.getElementsByClassName(\"doc-navigation\"); //voyagerPanel[0].style.background = \"#0e1726\" // var voyagerPanel = document.getElementsByClassName(\"scroll-area\"); // voyagerPanel[0].style.background = \"#0e1726\"; // var voyagerPanel = document.getElementsByClassName(\"contents\"); // voyagerPanel[0].style.background = \"#0e1726\" // var voyagerPanel = document.getElementsByClassName(\"doc-panel\"); // voyagerPanel[0].style.position = \"absolute\" // Makes the panel draggable, hopefully users will move it to a better position. // dragElement(voyagerPanel[0]); function dragElement(elmnt) { var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; elmnt.onmousedown = dragMouseDown; function dragMouseDown(e) { e = e || window.event; e.preventDefault(); // get the mouse cursor position at startup: pos3 = e.clientX; pos4 = e.clientY; document.onmouseup = closeDragElement; // call a function whenever the cursor moves: document.onmousemove = elementDrag; } function elementDrag(e) { e = e || window.event; e.preventDefault(); // calculate the new cursor position: pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY; pos3 = e.clientX; pos4 = e.clientY; // set the element's new position: elmnt.style.top = (elmnt.offsetTop - pos2) + \"px\"; elmnt.style.left = (elmnt.offsetLeft - pos1) + \"px\"; } function closeDragElement() { // stop moving when mouse button is released: document.onmouseup = null; document.onmousemove = null; } }  "});index.add({'id':3,'href':'/api-docs/docs/authencation/accesstoken/accesstoken/','title':"Access Token",'section':"Access Token",'content':"Access Tokens #  An access token can be used to query the Glimesh API on behalf of a user. You can also get info about the user that the token belongs to.\nRequesting A Token #  Before requesting a token you must have a developer application. You will need your client ID, secret ID, and redirect URL. First you need to have a user authenticate with your app. The user must be directed to https://glimesh.tv/oauth/authorize?response_type=code\u0026amp;state=\u0026amp;client_id=CLIENT_ID\u0026amp;scope=public%20email%20chat%20streamkey\u0026amp;redirect_uri=REDIRECT_URL\nMake sure to replace your client ID and your redirect URL. The redirect URL must match one of the URL\u0026rsquo;s on your application. Scopes are space separated values that determine what permissions you want from the user. Only request the scopes that you need.\nThe current scopes are:\n public: Get public information about the user and other users on Glimesh. email: View the email of the user. chat: View and speak in a chatroom. Note that speaking through the api is not yet supported. stream View the streamkey of the user.  When the user is sent to the link they will have to accept your app scopes. They will then be sent to your apps redirect URL. Glimesh will send a code inside the URL when they are sent back to your app. You need to extract it from the URL.\nhttp://your-app.com/some/area?code=qwertyuiop123\nOnce you have the code you need to make a request to Glimesh. We will exchange the code for an access token.\nPOST https://glimesh.tv/api/oauth/token?grant_type=authorization_code\u0026amp;code=CODE\u0026amp;redirect_uri=REDIRECT_URL\u0026amp;client_id=CLIENTID\u0026amp;client_secret=SECRETID\nSend a POST request with the URL above replacing the code,redirect url, client ID, and secret ID. Remember to keep the secret ID hidden from your users. When Glimesh receives the POST request it will send back the information we want. Once it is parsed it will look like this:\n{ access_token: \u0026#39;qwertyuiopo1234567890\u0026#39;, created_at: \u0026#39;2020-12-14T15:15:29\u0026#39;, expires_in: 21600, refresh_token: \u0026#39;qwertyuiop0987654321\u0026#39;, scope: \u0026#39;public email chat streamkey\u0026#39;, token_type: \u0026#39;bearer\u0026#39; } Now you can query the Glimesh API on behalf of a user. This token will expire after a few hours so you need to refresh it or ask the user for a new one. If you have any questions talk to us in the #dev channel in our Discord.\n Ready to refresh your token? Continue with OAuth here\n Common Errors #  There are a few errors you may encounter while requesting a token.\n{ error: \u0026#39;invalid_grant\u0026#39;, error_description: \u0026#39;The provided authorization grant is invalid, expired, revoked, does not match the redirection URI used in the authorization request, or was issued to another client.\u0026#39; } This means something is wrong with your URL. You can only use each code once. You must send the request with the grant_type=authorization_code for Glimesh to send you the access token. Ensure all of the data in the URL matches the data in your dev application. Glimesh will refuse any request that is not properly formatted.\n{ error: \u0026#39;invalid_request\u0026#39;, error_description: \u0026#39;The request is missing a required parameter, includes an unsupported parameter value, or is otherwise malformed.\u0026#39; } This is a request error. Some part of your URL is not necessary or missing. Ensure the parameters in the URL are spelled correctly. You should also check that you have all of the required data in the URL.\nError: 401 Unauthorized. You must be logged in to access the API.\nThis is an authentication issue. This is commonly seen when querying the API but I added it here because it most likely means you must request another token. You must renew or request a new token and send the API request to Glimesh properly. Tokens expire after a few hours unless they are renewed.\n Stuck with something? Talk to us in Discord. We would be happy to help you!\n "});index.add({'id':4,'href':'/api-docs/docs/authencation/accesstoken/nodejs/node-access-token/','title':"Node Access Token",'section':"Access Token",'content':"Getting User Tokens With NodeJS #  This is a basic tutorial for getting an auth token from a user using Oauth with NodeJS. This guide assumes you know basic JS and understand the workings of Oauth 2.\n Need a refresh? This tutorial explains the basics of Oauth 2 https://darutk.medium.com/the-simplest-guide-to-oauth-2-0-8c71bd9a15bb\n Creating the Project #  We need to create a basic project. In your terminal type:\nnpm init -y\nThis will create a project.JSON file. This project uses the Express and Request packages. Install them with:\nnpm install express request\nThese packages will help us set up a basic web server and send requests to Glimesh.\nStarting Up #  In your project create a blank JS file. I will title mine auth.js. Start by importing Express. Paste this at the top of your file.\nconst express = require(\u0026#39;express\u0026#39;); //Express package const app = express(); // Creates endpoints for the server. const request = require(\u0026#39;request\u0026#39;); //Request package var clientID = \u0026#34;\u0026#34;; // ID for connecting your users to your app. var secretID = \u0026#34;\u0026#34;; //ID to verify your app, keep private.  This imports the modules our server will need. The server will use the app variable for creating endpoints. The IDs are used so Glimesh can identify our app. We will insert the IDs later.\nCreating the server #  First we need to tell the server to listen for connections. We also need to tell the server which port to be on. I would recommend 8080 or 3000. Paste this in your file:\nconst port = process.env.PORT || 3000; //Opens the server on port 3000 app.listen(port, () =\u0026gt; console.log(\u0026#39;App listening on port \u0026#39; + port)); //keeps the server running^  This will keep the server from closing by itself. Now we can create endpoints for our users to connect to. One will redirect to the Glimesh auth page (/oauth/authorize) and the other will handle the auth info sent from Glimesh. You can create a web page for the first endpoint if you wish. For the sake of this tutorial I will keep it a simple redirect. Paste this in your file:\n//When a user visits http://localhost:3000/auth app.get(\u0026#39;/auth\u0026#39;, (req, res) =\u0026gt; { //redirects the user to the glimesh authenication page res.redirect(301, \u0026#39;https://glimesh.tv/oauth/authorize?response_type=code\u0026amp;state=\u0026amp;client_id=\u0026#39; + clientID + \u0026#39;\u0026amp;scope=public%20email%20chat%20streamkey\u0026amp;redirect_uri=http://localhost:3000/success\u0026#39;); }); In this URL we send the client ID, the redirect URL, and a set of scopes that we want access to. We also request a code in the response_type. Next we will create a developer application. This will give us a client ID and a secret ID.\n If you have a web page that you want your users to access when they go to this endpoint you can send it to them by using res.sendFile(\u0026quot;FILE_NAME.html\u0026quot;) You would need to have a button or other method to send them to the authentication page.\n Developer Applications #  Before we can request Oauth permissions we need a developer application. This is what Glimesh will use to authenticate users for your app. It is also how Glimesh can monitor and identify requests you and your users send. Click here to create your developer application.\nSet up your dev application like this. Use a unique name and description. You can update these at any time. Ensure that the homepage of your app is http://localhost:3000 and your redirect link is http://localhost:3000/success. You must replace the port number if you used a different port.\nSave your app when you are finished.\nGetting the Token #  Now that we have a developer app we can update our variables. Set it equal to your client ID and secret ID. It is very important to keep the secret ID hidden from your users. If your ID is leaked you can reset them from the Glimesh dev app page but your users must authenticate again.\nvar clientID = \u0026#34;CLIENT_ID_HERE\u0026#34; var secretID = \u0026#34;SECRET_HERE\u0026#34; We need to create an endpoint for Glimesh to redirect to. In the previous section we told Glimesh to redirect to locahhost:3000/success. Let\u0026rsquo;s create it!\napp.get(\u0026#34;/success\u0026#34;, (req, res) =\u0026gt; { let code = req.query.code; console.log(\u0026#34;The code is \u0026#34; + code); res.send(`\u0026lt;h1\u0026gt;code recieved!\u0026lt;/h1\u0026gt;`) //Sends a confirmation message to the user }); When our user is redirected to our server the token is sent in the URL as ?code=CODE_HERE. We pull the code from URL and log it to the console.\nOnce you have the code you can request the token from Glimesh. This can be done with a simple Request function. When we get a response we parse it and log it to the console. Update the code for the /success endpoint as follows:\napp.get(\u0026#34;/success\u0026#34;, (req, res) =\u0026gt; { let code = req.query.code; console.log(\u0026#34;The code is \u0026#34; + code); res.send(`\u0026lt;h1\u0026gt;Code recieved, requesting token!\u0026lt;/h1\u0026gt;`) //Sends a confirm message to the user  //Now we send this code to Glimesh to ask for a token.  var options = { method: \u0026#39;POST\u0026#39;, body: \u0026#34;\u0026#34;, url: \u0026#34;https://glimesh.tv/api/oauth/token?grant_type=authorization_code\u0026amp;code=\u0026#34; + code + \u0026#34;\u0026amp;redirect_uri=http://localhost:3000/success\u0026amp;client_id=\u0026#34; + clientID + \u0026#34;\u0026amp;client_secret=\u0026#34; + secretID }; request(options, (error, response, body) =\u0026gt; { if (!error \u0026amp;\u0026amp; response.statusCode == 200) { //If all is as it should be  console.log(body); //The unfiltered response  var data = JSON.parse(body); console.log(data) } else { console.log(error) //log any errors  console.log(response.statusCode) console.log(body) } }); }); Save the file when you are finished. Let\u0026rsquo;s test our code! In your terminal type:\nnode FILE_NAME.js\nReplace FILE_NAME with the name of your file. This will start up the web server. Some antivirus programs may block the process because other devices on your network can access this server. Simply allow the port number you used in your antivirus software if this is the case. You may want to restart the server.\nOnce that is complete and the server is running head to http://localhost:3000/auth replacing the port number with the correct port. It will redirect you to your client application page. Accept it and it will redirect you back to your server at the /success endpoint.\n Please note that you must be logged in before authorizing. A bug prevents you from entering your account info and proceeding to the client app screen. If you are not logged in you must sign in and then go back to /auth\n You should see a confirmation message in your browser. The server is now sending the code back to Glimesh to request a token. Check the console in your terminal to see the code!\nYou can use the access_token to query the API on the users behalf. This will expire after a few hours so you will need to refresh the token or get a new one. If you have any question talk to us in the #dev channel in our Discord. We would love to hear what you are making!\nThe full file can be found here.\nconst express = require(\u0026#39;express\u0026#39;); //Express package const app = express(); // Creates endpoints for the server. const request = require(\u0026#39;request\u0026#39;); //Request package var clientID = \u0026#34;\u0026#34;; // ID for connecting your users to your app. var secretID = \u0026#34;\u0026#34;; //ID to verify your app, keep private.  const port = process.env.PORT || 3000; //Opens the server on port 3000 app.listen(port, () =\u0026gt; console.log(\u0026#39;App listening on port \u0026#39; + port)); //keeps the server running^  //When a user visits http://localhost:3000/auth app.get(\u0026#39;/auth\u0026#39;, (req, res) =\u0026gt; { //redirects the user to the glimesh authenication page \tres.redirect(301, \u0026#39;https://glimesh.tv/oauth/authorize?response_type=code\u0026amp;state=\u0026amp;client_id=\u0026#39; + clientID + \u0026#39;\u0026amp;scope=public%20email%20chat%20streamkey\u0026amp;redirect_uri=http://localhost:3000/success\u0026#39;); }); app.get(\u0026#34;/success\u0026#34;, (req, res) =\u0026gt; { let code = req.query.code; console.log(\u0026#34;The code is \u0026#34; + code); res.send(`\u0026lt;h1\u0026gt;Code Recieved!\u0026lt;/h1\u0026gt;`) //Sends a confirm message to the user \t//Now we send this code to Glimesh to ask for a token. \tvar options = { method: \u0026#39;POST\u0026#39;, body: \u0026#34;\u0026#34;, url: \u0026#34;https://glimesh.tv/api/oauth/token?grant_type=authorization_code\u0026amp;code=\u0026#34; + code + \u0026#34;\u0026amp;redirect_uri=http://localhost:3000/success\u0026amp;client_id=\u0026#34; + clientID + \u0026#34;\u0026amp;client_secret=\u0026#34; + secretID }; request(options, (error, response, body) =\u0026gt; { //Send glimesh the code for a token in return \tif (!error \u0026amp;\u0026amp; response.statusCode == 200) { //If all is as it should be \tconsole.log(body); //The unfiltered response \tvar data = JSON.parse(body); //The parsed response \tconsole.log(data) // The data we want! \t} else { console.log(error) //log any errors \tconsole.log(response.statusCode) //Status code if an error occurs \tconsole.log(body) //The body for more info \t} }); }); "});index.add({'id':5,'href':'/api-docs/docs/authencation/refreshtoken/refreshtoken/','title':"Refresh Token",'section':"Refresh Token",'content':"Refresh Tokens #  A refresh token allows you to get a new access token without having your user authenticate again. It is a standard part of OAuth 2.\n Looking for authentication flow? Start with access tokens\n Refreshing A Token #  Refresh tokens are sent when you request an access token. You can pull them from the data that Glimesh sends you.\n{ access_token: \u0026#39;qwertyuiopo1234567890\u0026#39;, created_at: \u0026#39;2020-12-14T15:15:29\u0026#39;, expires_in: 21600, refresh_token: \u0026#39;qwertyuiop0987654321\u0026#39;, scope: \u0026#39;public email chat streamkey\u0026#39;, token_type: \u0026#39;bearer\u0026#39; } You can refresh a token at any time. You do not need to wait for the access token to expire. Refresh tokens last for about one year. When you refresh a token you will need all the info from when you requested an access token.\nSend a POST request to:\nhttps://glimesh.tv/api/oauth/token?grant_type=refresh_token\u0026amp;refresh_token=REFRESH_TOKEN\u0026amp;redirect_uri=REDIRECT_URL\u0026amp; client_id=CLIENT_ID\u0026amp;client_secret=SECRET_ID Make sure to replace REFRESH_TOKEN, REDIRECT_URL, CLIENT_ID, and SECRET_ID with their corresponding values. They must match the values that were sent when you requested an access token. If you want new scopes you must request a new token.\nProvided you formatted your request correctly Glimesh will send you back a new refresh token and access token.\n{ \u0026#34;access_token\u0026#34;: \u0026#34;qwertyuioip123456789\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2020-12-21T23:08:22\u0026#34;, \u0026#34;expires_in\u0026#34;: 21600, \u0026#34;refresh_token\u0026#34;: \u0026#34;qwertyuiop098765321\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;public email chat streamkey\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34; } This will allow you to use the new token and continue to query the Glimesh API. You must use the new access token and the new refresh token. You can safely discard the old tokens.\nOther Info #   You cannot get new scopes from refresh tokens. You must make the user authenticate again with the new scopes. Access tokens last for about 6 hours. You can refresh them earlier if needed. Refresh tokens last for about 1 year. If a user revokes your dev app you cannot use the access or refresh tokens. This would require the user to authenticate again.  If you have any questions talk to us in the #dev channel in our Discord.\n"});index.add({'id':6,'href':'/api-docs/docs/chat/mutations/','title':"Mutations",'section':"Chat",'content':"Chat Mutations #  This tutorial will enable you to query and send messages to the chat using the Glimesh API. If you are looking to build a chatbot or other program that needs a constant connection view this tutorial. To connect to a chat you will need an access token or a client ID. Keep in mind that using a client ID will keep you in read-only mode for chat environments. The access token must have the chat scope to post messages.\nStarting Up #  Since we are not using a websocket connection we have to manually query and send chat messages. This is done through the Glimesh API. We can query any channel for chat messages. We can also send messages to any channel that we choose. Understanding how API requests work will be important for completing this tutorial.\n New to the API? Read this before starting.\n Authentication #  All API requests must contain the proper authentication. The authentication value should be included as a header of the request. This value will change depending on the authentication type. For access tokens use:\nAuthorization: 'Bearer YOUR_TOKEN' .\nReplace \u0026ldquo;YOUR_TOKEN\u0026rdquo; with your access token. If you are using a client ID to authenticate you must use this instead:\nAuthorization: 'Client-ID YOUR_CLIENT_ID'\nReplace \u0026ldquo;YOUR_CLIENT_ID\u0026rdquo; with your ID. This will allow you access to the API.\n A client ID can only use the API in read only mode. An access token must have the chat scope.\n Querying Existing Messages #  We need to set up a query to gather the chat messages. You will need the channel ID of a streamer to get the messages. You can get a channel ID with this query. Replace Mytho with the name of the user that you want the ID from.\nquery { channel(username: \u0026#34;Mytho\u0026#34;) { id } } Once you have the ID we can build our request. The query needs to be in the body of the request. You must send the query as a POST request. Structure it as follows:\nquery { channel(id:ID) { chatMessages { message, user { username, avatarUrl } } } }  Don\u0026rsquo;t forget to replace ID with the channel ID! If you want more data you can view the chatMessage reference here\n Glimesh will respond with a set of JSON data. You need to parse it to get the data that you want.\n{ \u0026#34;data\u0026#34;: { \u0026#34;channel\u0026#34;: { \u0026#34;chatMessages\u0026#34;: [ { \u0026#34;message\u0026#34;: \u0026#34;Glimesh is pretty great!\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://glimesh-user-assets.nyc3.cdn.digitaloceanspaces.com/uploads/avatars/Mytho.png?v=63762672056\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } }, { \u0026#34;message\u0026#34;: \u0026#34;Hello there\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://glimesh-user-assets.nyc3.cdn.digitaloceanspaces.com/uploads/avatars/Mytho.png?v=63762672056\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } }, // and so on... Sending Messages #  The Glimesh API uses mutations to send messages. The request must contain this mutation with a channel ID and a chat message. Structure it as show below. Make sure to replace MESSAGE with your chat message and ID with your channel ID.\nmutation { createChatMessage(channelId:6, message: {message: \u0026#34;MESSAGE\u0026#34;}) { message, insertedAt, user { username } } }  This should go in the body of the request.\n Glimesh will return with the message that was sent to chat. If you want more data you have to request it. The chatMessage reference can be found here.\n{ \u0026#34;data\u0026#34;: { \u0026#34;createChatMessage\u0026#34;: { \u0026#34;insertedAt\u0026#34;: \u0026#34;2021-01-08T05:03:44\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;MESSAGE\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;AFaithfulServant\u0026#34; } } } } This is all of the info required to interact with the chat API. Although this is a viable method, using websockets is the standard way of connecting to the chat. Websockets provide a constant connection and eliminates the need to query the API for new information. This is essential for services such as chatbots. If you have any questions talk to us in our discord.\n"});index.add({'id':7,'href':'/api-docs/docs/chat/projects/sitewidesubscription/','title':"Site Wide Subscription",'section':"Projects",'content':"Site Wide Chat Messages #  The Glimesh API allows you to subscribe to any channel to listen for chat messages. There is no limit to the amount of channels that you can listen to. In this project we will listen for every chat message from every user across the entire site. Before starting you should fully understand the WebSocket Tutorial.\nFirst we need to open a websocket connection to Glimesh. Use the process from the websocket tutorial linked above to get the connection open. Instead of subscribing to a specific channel you want to subscribe to the chatMessage event. You can do so with this:\n[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;doc\u0026#34;,{\u0026#34;query\u0026#34;:\u0026#34;subscription{ chatMessage { user { username avatar } message } }\u0026#34;}] Normally the event requires a channel ID as a parameter. Since we don\u0026rsquo;t specify which channel to listen to it connects to every channel on the site. All you have to do is log the messages as they come in!\n[null,null,\u0026#34;__absinthe__:doc:-576460752298178591:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;,\u0026#34;subscription:data\u0026#34;,{\u0026#34;result\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;chatMessage\u0026#34;:{\u0026#34;message\u0026#34;:\u0026#34;hello world!\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;avatar\u0026#34;:\u0026#34;/uploads/avatars/Mytho.png?v=63762672056\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;Mytho\u0026#34;}}}},\u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752298178591:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;}] In the example above we requested the message as well as the username and avatar of the chatter. This query shows all of the possible data we can get from a chat message.\nsubscription { chatMessage { id, insertedAt, message, updatedAt, channel { # Channel data }, user { # User data } } } This is all of the info required to listen to every chatroom. If you have any questions talk to us on our Discord.\n"});index.add({'id':8,'href':'/api-docs/docs/chat/websockets/','title':"Websockets",'section':"Chat",'content':"Chat WebSockets #  Glimesh uses WebSockets to allow for constant communication between you and the chat API. To connect to a chat you will need an access token or a client ID. Keep in mind that using a client ID will keep you in read-only mode for chat environments. The access token must have the chat scope to post messages.\nPreparing the Connection #  First, build your URL that you will connect to. It should look like this:\nwss://glimesh.tv/api/socket/websocket?vsn=2.0.0\u0026amp;token=TOKEN_HERE That URL is for access token authentication. If you are using a client ID use this instead:\nwss://glimesh.tv/api/socket/websocket?vsn=2.0.0\u0026amp;client_id=CLIENT_ID  Make sure to replace TOKEN_HERE or CLIENT_ID with the proper token or ID.\n Start by opening a secure websocket connection to the URL you are using. When the connection is opened we send Glimesh a join request in JSON format to stay connected to the socket. The array below is a example of what this should look like.\n[\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;__absinthe__:control\u0026quot;,\u0026quot;phx_join\u0026quot;,{}] Notice that this is a JSON array. Some WebSocket libraries only allow you to send strings or specially formatted JSON. Sometimes you need to encase the data in a string. If the connection closes immediately you may need to change the type of your request. This depends purely on your library, if you are having trouble talk to us in our discord.\n Javascript example using the ws NPM package:\nconnection.send([\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_join\u0026#34;,{}]); // Doesn\u0026#39;t work :( connection.send(\u0026#39;[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_join\u0026#34;,{}]\u0026#39;); // Option 1 connection.send(JSON.stringify([\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_join\u0026#34;,{}])); //Safer option  The first value is the join ref. The second is the normal ref. They can be useful for multi-connections but we will use the value of 1 for all refs in this doc. The third is the topic. The fourth is the event. The fifth is for a payload. Glimesh does not require a payload for this request so we can leave this blank {} .\nIf Glimesh successfully receives our request we will get a response similar to what we sent. Notice that the first two values are the same. The response tells us that Glimesh is ready.\n[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] Joining Chat #  Now that Glimesh has accepted our connection we can connect to a chat. You will need a channel ID for the channel you want to connect to. If you do not know the channel ID you can query the API for it. Simply replace Mytho with the proper user.\nquery { channel(username: \u0026#34;Mytho\u0026#34;) { id } }  Remember: Channel IDs and user IDs are different things. Everyone is a user but not everyone has a channel.\n Once you have the ID we can join the chat. Send this through the connection:\n[\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;__absinthe__:control\u0026quot;,\u0026quot;doc\u0026quot;,{\u0026quot;query\u0026quot;:\u0026quot;subscription{ chatMessage(channelId: 6) { user { username avatar } message } }\u0026quot;,\u0026quot;variables\u0026quot;:{} ] Make sure to replace 6 with your channel ID! The query we just sent will determine what data is sent to us every time a chat message appears in chat. In this example we requested the message and the user who sent it. We ask for the username and avatar of the user in the user object.\n To view a list of everything you can request check out the API docs here (Docs =\u0026gt; subscription =\u0026gt; chatMessage).\n Glimesh will send us a response:\n[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{\u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752303349214:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] Now we are connected to chat! The only thing left to do is send a heartbeat to Glimesh so the connection won\u0026rsquo;t be closed. You need to send a heartbeat every 30 seconds. Structure it as follows:\n[\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;phoenix\u0026quot;,\u0026quot;heartbeat\u0026quot;,{}] Glimesh will respond with:\n[\u0026#34;null\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;phoenix\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] Now Glimesh won\u0026rsquo;t disconnect us and we have a stable chat connection! Next we will parse incoming messages and send messages back to chat.\nIncoming Messages #  First let\u0026rsquo;s handle incoming messages. A chat message sent from the API would look like this:\n[null,null,\u0026#34;__absinthe__:doc:-576460752298178591:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;,\u0026#34;subscription:data\u0026#34;,{\u0026#34;result\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;chatMessage\u0026#34;:{\u0026#34;message\u0026#34;:\u0026#34;hello world!\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;avatar\u0026#34;:\u0026#34;/uploads/avatars/Mytho.png?v=63762672056\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;Mytho\u0026#34;}}}},\u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752298178591:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;}] It is returning the data that we requested when we connected to this channel. The subscription ID helps you keep track of which channel the message is from. When you receive a message you need to parse the JSON data. Then you can get any of the data from the response.\n The chat API is being worked on so the structure will likely change in a future update.\n Sending Messages #  Next we will send a message back to chat. We must use a mutation to do so. Send this to chat:\n[\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;__absinthe__:control\u0026quot;,\u0026quot;doc\u0026quot;,{\u0026quot;query\u0026quot;:\u0026quot;mutation {createChatMessage(channelId:6, message: {message: \\\u0026quot;Hello There!\\\u0026quot;}) {message }}\u0026quot;,\u0026quot;variables\u0026quot;:{}}]  Don\u0026rsquo;t forget to replace 6 with your channel ID and Hello World with your message! The \\ before the quotes are used to prevent the JSON structure from breaking. Depending on how your lib handles ws messages they may not be necessary. The format for sending messages is very strict, ensure Glimesh receives your data as valid JSON.\n Only access tokens with the chat scope can talk in chat. Client IDs are read only. In the above data we requested to have the message returned to us when Glimesh sent it to chat. Glimesh will confirm that the message was received:\n[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;createChatMessage\u0026#34;:{\u0026#34;message\u0026#34;:\u0026#34;Hello There!\u0026#34;}}},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] WebSocket API Queries #  You don\u0026rsquo;t need to disconnect from the connection to make a normal API request. You can send requests from within your websocket connection! As with normal queries you are limited by the scope of your access token or client ID. Let\u0026rsquo;s build a simple request.\nquery { followers(streamerUsername: \u0026#34;CHANNEL\u0026#34;) { id, user { username } } } In this example we request the ID and username of the followers of a channel. Replace CHANNEL with any streamer on Glimesh. Keep in mind that they must be a channel and not just a normal user. Add this query as the payload in the message that we will send to the API. As with all requests we must make this valid JSON before sending it to Glimesh.\n[\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;__absinthe__:control\u0026quot;,\u0026quot;doc\u0026quot;,{\u0026quot;query\u0026quot;:\u0026quot;query {followers(streamerUsername: \\\u0026quot;CHANNEL\\\u0026quot;) {id,user {username}}}\u0026quot;}]  This snippet is already JSON, you may have to make adjustments depending on your websocket library.\n Glimesh will respond:\n[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;followers\u0026#34;:[{\u0026#34;id\u0026#34;:\u0026#34;613\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;username\u0026#34;:\u0026#34;Mytho\u0026#34;}},{\u0026#34;id\u0026#34;:\u0026#34;629\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;username\u0026#34;:\u0026#34;TheCat\u0026#34;}},{\u0026#34;id\u0026#34;:\u0026#34;752\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;username\u0026#34;:\u0026#34;Kirby\u0026#34;}},{\u0026#34;id\u0026#34;:\u0026#34;11992\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;username\u0026#34;:\u0026#34;RainbowFist\u0026#34;}}]}},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] This is all the info you will need to connect and use the chat API. If you have any questions talk to us in our discord!\nConnection Issues #  The most common issue is the connection closing with no message as to why. One of two things has happened:\n Heartbeat: You must send a heartbeat message to Glimesh every 30 seconds or Glimesh will drop the connection. Format: The chat API must receive data in the proper format. Most requests will need to be sent in a JSON array. The refs must be surrounded by quotes. The message in the mutation must also contain quotes. You may have to use a backslash to properly format the chat message. \\\u0026quot;message data\\\u0026quot;  "});index.add({'id':9,'href':'/api-docs/docs/contributing/','title':"Contributing",'section':"Docs",'content':"Contributing #  Thanks for wanting to contribute to the api-docs! We are grateful for your help.\nContributing to the API Docs. #  Anyone can contribute to the docs. We only ask that you follow a few guidelines when contributing.\n  Follow the file structure. Each topic (or sub-topic) has language specific folders and a basic guide. Inside each language folder there should be a tutorial and a code file if applicable. You do not need to tackle an entire topic by yourself. Completing even one tutorial is helpful!\n  Follow the tutorial structure. Try to keep each tutorial as objective as possible. You can have some personal expression but try to keep it limited. We want these guides to be as short and as simple as they can get. The tutorial should be written in Markdown. Explain every step and clearly document any code used. Don\u0026rsquo;t do this.\n  Run any code through a prettier software. Try to keep the code looking nice! It doesn\u0026rsquo;t matter which formatter you use but we want the code to be readable.\n  Follow the Glimesh and Github TOS (Terms of Service). Any tutorial that violates either of the TOS will be removed. Any malicious code will be removed.\n  Process #  Start by forking the repository. Access the fork on your PC or on https://github.com/YOURNAME/api-docs . You will want an environment capable of editing markdown (.md) files. Any IDE will do.\n Stack Edit is a free markdown editor running in the browser. It is easy to use and has many tools for markdown formatting. You can copy the contents of the files here to edit them.\n Option 1 #  Create (or edit) the tutorial in the Topics folder. You should try to mirror the directory structure within the repo. The file is a normal markdown file and does not have access to special extensions beyond the basic Github spec. If you have code included in your tutorial you should create a code file with all of the code you used in the same directory. When you are finished commit and push the changes. Finally create a pull request with a brief overview of your tutorial/topic. We may ask you to make changes. Once accepted we will add your tutorial to the repo and manually add it to the website.\nOption 2 #  This will allow you to view the tutorial on the api-docs website and use all of the special extensions/formatting available with Hugo. We use the book theme.\nYou will need to create your tutorial as described in the option above. You will also need Hugo installed. Get the extended features edition.\n This installation can be a bit complex for Windows users so you may want to follow a tutorial.\n In the command line navigate to the folder containing your fork. CD into the api-docs folder. Run hugo server --minify --theme book in your terminal. If you get a theme error you can run git clone https://github.com/alex-shpak/hugo-book themes/book. It will install the necessary theme files. When it finishes installing run the server command again. This will open a server on http://localhost:1313/api-docs.\n The server will restart when any changes are saved. Major changes will require a manual restart though.\n Create a copy of the markdown file you created above. You can add special formatting if you want to. You need to paste it in the api-docs/docs folder in the proper directory. If it is a new tutorial you should try to mirror the directory in the Topics folder. Hugo will detect the file and update the menu on the left side of the page with your new file. The menu will alter itself to match the file directory. This may require a restart of the server.\n Notice that every folder with content has a _index.md file. Create a new _index.md file and fill it with the info below if you created a new folder. This allows the tutorial to be collapsible in the menu. If the weight is the same they will be alphabetically sorted.\n --- bookCollapseSection: true weight: 20 --- When you are satisfied with the look of your tutorial you need to build the site. This will allow Github Pages to use the website. Close the server. In your terminal run hugo --theme book in the same directory. It will build the site to the docs folder. It should replace a few files. Commit and push your changes. Create a pull request with a brief overview of your tutorial/topic. We may ask you to make changes. Once accepted we will add your tutorial to the repo and add it to the website.\n Different versions and platforms treat Hugo differently. If the commands are not working talk to us in Discord or on the api-docs issues page.\n Thank you for contributing!\n"});index.add({'id':10,'href':'/api-docs/docs/dev-app/','title':"Dev App",'section':"Docs",'content':"Developer Application #  Although making an application is easy, developers new to OAuth may find some of it confusing. This tutorial will explain the basics of what information is asked for and what is it used for.\n Ready to make your application? Start here\n Name #  The name of your project is a user friendly name for your application. Both Glimesh and your users will see this when they authenticate with your app.\nHomepage #  The homepage of your app is where your product (if applicable) is located. This could be a website for a chatbot, an online tool, or anything that uses the Glimesh API. You do not need to have a public domain to show your product if you don\u0026rsquo;t want to. Using a localhost URL is fine.\nDescription #  The description is a basic explanation of your app. This should be a brief overview of what your app will be used for. Details, details, details!\nImage #  The image you choose here is shown to all users who authenticate with your app. It should be representative of your app and must not violate the Glimesh Terms of Service.\nAllowed Redirect URIs #  The redirect URIs are where Glimesh will redirect users of your app after they authenticate with your app. You specify which one to redirect to in the client request. You should have one URL per line. We prefer HTTPS over HTTP but using a locally hosted HTTP server will be fine.\nA complete dev app will look like this when authenticating.\n"});index.add({'id':11,'href':'/api-docs/docs/reference/api/','title':"Api",'section':"Reference",'content':"API Requests #  This document shows common API requests that may be of use. To see the most recent version of the API visit https://glimesh.tv/api in the docs section.\nRemove any comments before sending to Glimesh.\nCategory List #  Returns a list of all the categories. Query query { categories { id, # ID of the category name, # Name of the category slug, # Slug of the category (lowercase name) tagName, # The parent and current category: Art \u0026gt; Digital parent { # The parent category. Null if no parent exists. name # all of the above fields are available } } } Response This shows two of the categories returned.\n{ \u0026#34;data\u0026#34;: { \u0026#34;categories\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Gaming\u0026#34;, \u0026#34;parent\u0026#34;: null, \u0026#34;slug\u0026#34;: \u0026#34;gaming\u0026#34;, \u0026#34;tagName\u0026#34;: \u0026#34;Gaming\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;13\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Digital\u0026#34;, \u0026#34;parent\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Art\u0026#34; }, \u0026#34;slug\u0026#34;: \u0026#34;digital\u0026#34;, \u0026#34;tagName\u0026#34;: \u0026#34;Art \u0026gt; Digital\u0026#34; }, ] } }  "});index.add({'id':12,'href':'/api-docs/docs/reference/apireference/','title':"Api Reference",'section':"Reference",'content':"Remove any comments before sending to Glimesh.\nCategory List #  Returns a list of all the categories. Query query { categories { id, # ID of the category name, # Name of the category slug, # Slug of the category (lowercase name) tagName, # The parent and current category: Art \u0026gt; Digital parent { # The parent category. Null if no parent exists. name # all of the above fields are available } } } Response This shows two of the categories returned.\n{ \u0026#34;data\u0026#34;: { \u0026#34;categories\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Gaming\u0026#34;, \u0026#34;parent\u0026#34;: null, \u0026#34;slug\u0026#34;: \u0026#34;gaming\u0026#34;, \u0026#34;tagName\u0026#34;: \u0026#34;Gaming\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;13\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Digital\u0026#34;, \u0026#34;parent\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Art\u0026#34; }, \u0026#34;slug\u0026#34;: \u0026#34;digital\u0026#34;, \u0026#34;tagName\u0026#34;: \u0026#34;Art \u0026gt; Digital\u0026#34; }, ] } }  "});index.add({'id':13,'href':'/api-docs/docs/reference/chat/','title':"Chat",'section':"Reference",'content':"Chat #  Shows all of the fields in the chatMessage object.\nchatMessage { id, insertedAt, message, updatedAt, channel { // Channel data  }, user { // User data  } } \n"});index.add({'id':14,'href':'/api-docs/docs/reference/chatreference/','title':"Chat Reference",'section':"Reference",'content':"Shows all of the fields in the chatMessage object.\nchatMessage { id, insertedAt, message, updatedAt, channel { // Channel data  }, user { // User data  } } "});index.add({'id':15,'href':'/api-docs/docs/reference/scopes/','title':"Scopes",'section':"Reference",'content':"Scopes #  Scopes are permissions that a developer application requests from a client. The client must approve all of the scopes that you request. You should only request scopes that you plan to use. Below documents all of the available scopes.\n public: Get public information about the user and other users on Glimesh. email: View the email of the user. chat: View and speak in a chatroom. Note that speaking through the api is not yet supported. stream View the streamkey of the user.  Note that more scopes will be added when the chat API is fully complete.\n"});index.add({'id':16,'href':'/api-docs/docs/reference/scopesreference/','title':"Scopes Reference",'section':"Reference",'content':" public: Get public information about the user and other users on Glimesh. email: View the email of the user. chat: View and speak in a chatroom. Note that speaking through the api is not yet supported. stream View the streamkey of the user.  "});})();